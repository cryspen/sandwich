{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":""},{"location":"index.html#what-is-sandwich","title":"What is Sandwich?","text":"<p>Sandwich provides a simple, unified, and hard to misuse API for developers to use cryptographic algorithms and protocols of their choice in their applications.  Sandwich is written in Rust, and provides a C API with bindings for Python and Go. This API is implemented through various cryptographic libraries (OpenSSL and BoringSSL), and in particular supports libOQS, meaning Sandwich enables post-quantum cryptography.</p> <p>One goal of the library is to enable dynamic cryptographic agility, without the necessity of having to recompile or redeploy updated software.</p> <p> </p>"},{"location":"index.html#the-tunnel-abstraction","title":"The tunnel abstraction","text":"<p>Sandwich provides a secure tunnel abstraction. An example of such a tunnel is TLS. Sandwich slices the concept of tunnels into two different dimensions:</p> <ul> <li>a handshake plane where a shared key between two peers is generated</li> <li>a record plane where actual protected data is exchanged</li> </ul> <p>See the documentation for more details.</p>"},{"location":"index.html#runtime-cryptographic-agility","title":"Runtime cryptographic agility","text":"<p>Utilizing Sandwich enables software to have dynamic cryptographic agility, meaning that the choice of which cryptographic library backend is used can be selected at runtime. See TODO for an example.</p> <p>Sandwich implements the underlying cryptography functionality using existing cryptographic libraries, namely OpenSSL or BoringSSL.</p>"},{"location":"index.html#security-fixes","title":"Security fixes","text":"<p>Sandwich is keen to stay on top of performance and security fixes of the underlying libraries.</p>"},{"location":"index.html#license","title":"License","text":"<p>Sandwich is licensed under AGPL 3.0.</p>"},{"location":"index.html#disclaimer","title":"Disclaimer","text":"<p>The software and documentation are provided \"as is\" and SandboxAQ hereby disclaims all warranties, whether express, implied, statutory, or otherwise. SandboxAQ specifically disclaims, without limitation, all implied warranties of merchantability, fitness for a particular purpose, title, and non-infringement, and all warranties arising from course of dealing, usage, or trade practice. SandboxAQ makes no warranty of any kind that the software and documentation, or any products or results of the use thereof, will meet any person's requirements, operate without interruption, achieve any intended result, be compatible or work with any software, system or other services, or be secure, accurate, complete, free of harmful code, or error free.</p>"},{"location":"CHANGELOG.html","title":"Changelog","text":""},{"location":"CHANGELOG.html#v030-feb-23-2024","title":"v0.3.0 (Feb 23, 2024)","text":""},{"location":"CHANGELOG.html#major-changes","title":"Major changes","text":"<ul> <li>Experimental TurboTLS protocol implementation.</li> </ul>"},{"location":"CHANGELOG.html#minor-changes","title":"Minor changes","text":"<ul> <li>Revamped Go Language binding to workaround restriction Golang places on accessing c types across packages.</li> <li>Go helpers now always return blocking IOs.</li> </ul>"},{"location":"CHANGELOG.html#v020-feb-5-2024","title":"v0.2.0 (Feb 5, 2024)","text":""},{"location":"CHANGELOG.html#major-changes_1","title":"Major changes","text":"<ul> <li>Security fixes discovered by independent security research firm Trail of Bits.</li> <li>Support for OpenSSL 3.2.0 coupled with oqs-provider as a cryptographic backend.</li> <li>Support for TLS 1.2</li> <li>New APIs on top of OpenTelemetry which traces internal stages of a TLS connection along with data collection.</li> </ul>"},{"location":"CHANGELOG.html#minor-changes_1","title":"Minor changes","text":"<ul> <li>Fix an issue where protobuf versions did not match.</li> <li>Update liboqs to its latest version to fix the <code>DIV</code> issue in Kyber implementation.</li> <li>Accept standard Rust IO.</li> </ul>"},{"location":"CHANGELOG.html#v010-aug-8-2023","title":"v0.1.0 (Aug 8, 2023)","text":"<p>Initial public release</p>"},{"location":"c_api.html","title":"C API","text":"<ul> <li>sandwich.h API</li> <li>tunnel.h API</li> <li>io.h API</li> <li>listener.h API</li> <li>Error codes</li> <li>I/O errors</li> <li>Structures</li> </ul>"},{"location":"install.html","title":"Installation and integration","text":""},{"location":"install.html#c-api","title":"C API","text":"<p>There are two ways to utilize the Sandwich C API: using prebuilt packages, or by building from source.</p>"},{"location":"install.html#using-pre-built-packages","title":"Using pre-built packages","text":"<p>Pre-built packages can be found on the Sandwich releases Github section. It is precompiled for Linux and MacOS, targetting both amd64 and aarch64 (arm64).</p>"},{"location":"install.html#building-from-source","title":"Building from source","text":"<p>The Sandwich build system is based on Bazel. See Installing Bazel for more bazel setup information.</p> <p>To build Sandwich, you must first install the necessary build-time dependencies. Platform specific dependency installation instructions are documented below, depending on whether you are building on Linux or MacOS</p>"},{"location":"install.html#installing-bazel","title":"Installing Bazel","text":"<p>We recommend using Bazelisk to install Bazel. You can use the Bazelisk pre-built releases, and add the <code>bazelisk</code> binary in your <code>PATH</code>.</p>"},{"location":"install.html#linux-specific-build-dependencies","title":"Linux-specific build dependencies","text":"<p>To install dependencies in Debian-like systems:</p> <pre><code># apt install clang-13 lld-13 python3 python3-dev cmake ninja-build git\n</code></pre> <p>These environment variables need to be set:</p> <ul> <li><code>export CC=clang-13</code></li> <li><code>export CXX=clang++-13</code></li> <li><code>export LD=lld-13</code></li> </ul>"},{"location":"install.html#macos-specific-build-dependencies","title":"MacOS-specific build dependencies","text":"<p>MacOS builds require installing XCode.</p>"},{"location":"install.html#build-sandwich","title":"Build sandwich","text":"<p>Use Bazel to build a release version of Sandwich:</p> <pre><code>bazelisk build //:export -c opt\n</code></pre> <p>This will generate an archive in <code>bazel-bin/sandwich_bin.tar.gz</code> that contains the sandwich C API headers alongside a static and shared library version of Sandwich:</p> <pre><code>$ tar tf /path/to/sandwich/bazel-bin/sandwich_bin.tar.gz\ninclude/\ninclude/sandwich_c/sandwich.h\ninclude/sandwich_c/tunnel.h\n[...]\nlib/\nlib/libsandwich_full.a\n[...]\n</code></pre>"},{"location":"install.html#go-api","title":"Go API","text":"<p>The Sandwich Go bindings can be added in a project using <code>go get</code>:</p> <pre><code>$ go get github.com/sandbox-quantum/sandwich/go\n</code></pre> <p>The Go bindings rely on the Sandwich C API. In order to build a Go project that is using Sandwich, some <code>cgo</code> environment variables need to be set to tell the Go compiler where to find the Sandwich C headers and compiled static library.</p> <p>A compiled version of the Sandwich C API can be either directly downloded from the Sandwich releases Github section, or built from source.</p> <p>Assuming the Sandwich C API release has been extracted into <code>$SANDWICH_ROOT</code>, these environment variables need to be set at build time:</p> <pre><code>$ export CGO_CFLAGS=\"-I$SANDWICH_ROOT/include\"\n$ export CGO_LDFLAGS=\"-L$SANDWICH_ROOT/lib\"\n</code></pre>"},{"location":"install.html#python-api","title":"Python API","text":"<p>The Python API can be installed with pip with:</p> <pre><code>$ pip install pysandwich\n</code></pre> <p>It can also be installed from source: <pre><code>$ cd /path/to/sandwich\n$ pip install .\n</code></pre></p> <p>At runtime, the Sandwich Python bindings will be looking for <code>libsandwich_full.so</code>, which can be either directly downloaded from the Sandwich releases Github section, or built from source.</p> <p>The <code>SANDWICH_C_LIB</code> environment variable can point to the path where <code>libsandwich_full.so</code> has been installed. The bindings will also look for the library in standard operating system's paths.</p>"},{"location":"install.html#rust-api","title":"Rust API","text":""},{"location":"install.html#using-cargo","title":"Using cargo","text":"<pre><code>[dependencies]\nsandwich = { git = \"https://github.com/sandbox-quantum/sandwich.git\" }\n</code></pre> <p><code>cargo add</code> can also be used to append Sandwich into the dependencies section of an existing <code>Cargo.toml</code> file:</p> <pre><code>$ cargo add --git 'https://github.com/sandbox-quantum/sandwich.git' sandwich\n</code></pre>"},{"location":"install.html#from-source","title":"From source","text":"<p>The Rust API can be built and tested from source with <code>cargo</code>:</p> <pre><code>$ cargo build\n$ cargo test\n</code></pre>"},{"location":"install.html#rust-documentation","title":"Rust documentation","text":"<p>Use <code>cargo doc</code> to build the Rust documentation:</p> <pre><code>$ cargo doc\n</code></pre>"},{"location":"install.html#features","title":"Features","text":"<p>Sandwich has the following features:</p> feature description enabled by default <code>openssl1_1_1</code> Enable support for OpenSSL 1.1.1 built with <code>liboqs</code> <code>true</code> <code>boringssl</code> Enable support for BoringSSL built with <code>liboqs</code> <code>true</code> <code>ffi</code> Enable the FFI interface <code>false</code>"},{"location":"install.html#unit-tests","title":"Unit tests","text":"<p>Sandwich unit tests can be run directly using Bazel:</p> <pre><code>$ cd /path/to/sandwich &amp;&amp; bazelisk test ...\n</code></pre>"},{"location":"install.html#integration-with-bazel","title":"Integration with Bazel","text":"<p>To use Sandwich in a Bazel project, add the following to your <code>WORKSPACE</code> file:</p> <pre><code>load(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\")\nhttp_archive(\nname = \"sandwich\",\nsha256 = \"86bd6328e5cbdca7851e9772e4c1dda1a435e15686497dfc8fecadd4a4639920\",\nstrip_prefix = \"sandwich-0.2.0\",\nurls = [\n\"https://github.com/sandbox-quantum/sandwich/archive/refs/tags/v0.2.0.tar.gz\",\n],\n)\nload(\"@sandwich//bazel:repositories.bzl\", \"sandwich_repositories\")\nsandwich_repositories()\nload(\"@sandwich//bazel:deps.bzl\", \"sandwich_deps\")\nsandwich_deps()\nload(\"@sandwich//bazel:python_deps.bzl\", \"sandwich_python_deps\")\nsandwich_python_deps()\nload(\"@sandwich//bazel:python_pypi_deps.bzl\", \"sandwich_python_pypi_deps\")\nsandwich_python_pypi_deps()\nload(\"@sandwich//bazel:rust_deps.bzl\", \"sandwich_rust_deps\")\nsandwich_rust_deps()\nload(\"@com_sandboxquantum_bartleby//bartleby:deps.bzl\", \"bartleby_deps\")\nbartleby_deps()\n</code></pre>"},{"location":"python_api.html","title":"Python API","text":"<p>Sandwich Python API.</p> <p>This API provides a way to use Sandwich from Python.</p> <p>It wraps Sandwich primitives into classes for convenience. It also provides the protobuf API for building Sandwich Contexts and Tunnels.</p> The following classes are defined <ul> <li>Sandwich: general handle responsible for ffi using ctypes.CDLL.</li> <li>IO: abstract class to define an I/O interface.</li> </ul> <p>To be able to use this API, the user has to define its own I/O interface. See <code>io.py</code> for more information.</p> <p>Sandwich I/O API.</p> <p>This API provides an I/O interface in Python, to use with Sandwich. It wraps a <code>struct SandwichIO</code>.</p> <p>An I/O interface is an object requiring the following methods:     * read(n: int) -&gt; bytes     * write(buf: bytes) -&gt; int</p> <p>All methods should either return the corresponding value (the read bytes for <code>read</code> and the amount of successfully written bytes for <code>write</code>), or raise an exception of type <code>IOException</code>.</p> <p>The user has to define a class extending <code>IO</code>. An example can be found in <code>tunnel_test.py</code>.</p> <p>Sandwich Error API.</p> <p>This API provides error types by inheriting the <code>Exception</code> class. Error codes come from the <code>.proto</code> file.</p> <p>All sandwich exceptions are based on <code>SandwichException</code>.</p> This file defines the following exception families <ul> <li><code>SandwichGlobalException</code>: exceptions that can happen all across the   library.</li> <li><code>HandshakeException</code>: exceptions happening during the handshake stage   (from <code>Tunnel.handshake()</code>).</li> <li><code>HandshakeError</code>: exceptions relating to errors encountered by the implementation</li> <li><code>RecordPlaneException</code>: exceptions happening in <code>Tunnel.read</code> or   <code>Tunnel.write</code>.</li> <li><code>IOException</code>: exceptions happening in the I/O interface (see <code>io.py</code>).</li> </ul> <p>All exceptions are based on the error codes defined by the following protobuf:     * <code>errors.proto</code>: <code>SandwichGlobalException</code>     * <code>tunnel.proto</code>: <code>HandshakeException</code> and <code>RecordPlaneException</code>     * <code>io.proto</code>: <code>IOException</code>.</p> <p><code>SandwichException</code> exposes a <code>code</code> method to get the corresponding error code. This error code is compatible with the C++ library.</p>"},{"location":"python_api.html#pysandwich.sandwich.Sandwich","title":"<code>Sandwich</code>","text":"<p>Top-level Sandwich context library.</p> Source code in <code>pysandwich/sandwich.py</code> <pre><code>class Sandwich:\n\"\"\"Top-level Sandwich context library.\"\"\"\n_handle: ctypes.c_void_p\ndef __init__(self):\nself._handle = sandwich().c_call(\"sandwich_lib_context_new\")\ndef _get_handle(self) -&gt; ctypes.c_void_p:\nreturn self._handle\ndef __del__(self):\nsandwich().c_call(\"sandwich_lib_context_free\", self._handle)\nself._handle = ctypes.c_void_p(None)\n</code></pre>"},{"location":"python_api.html#pysandwich.sandwich.TunnelConfigurationSerialized","title":"<code>TunnelConfigurationSerialized</code>","text":"<p>             Bases: <code>Structure</code></p> <p>The <code>struct SandwichTunnelConfigurationSerialized</code>.</p> Source code in <code>pysandwich/sandwich.py</code> <pre><code>class TunnelConfigurationSerialized(ctypes.Structure):\n\"\"\"The `struct SandwichTunnelConfigurationSerialized`.\"\"\"\n_fields_ = [\n(\n\"src\",\nctypes.c_char_p,\n),\n(\n\"n\",\nctypes.c_size_t,\n),\n]\n</code></pre>"},{"location":"python_api.html#pysandwich.sandwich.TunnelContextConfigurationSerialized","title":"<code>TunnelContextConfigurationSerialized</code>","text":"<p>             Bases: <code>Structure</code></p> <p>The <code>struct SandwichContextTunnelConfigurationSerialized</code>.</p> Source code in <code>pysandwich/sandwich.py</code> <pre><code>class TunnelContextConfigurationSerialized(ctypes.Structure):\n\"\"\"The `struct SandwichContextTunnelConfigurationSerialized`.\"\"\"\n_fields_ = [\n(\n\"src\",\nctypes.c_char_p,\n),\n(\n\"n\",\nctypes.c_size_t,\n),\n]\n</code></pre>"},{"location":"python_api.html#pysandwich.sandwich.sandwich","title":"<code>sandwich()</code>","text":"<p>Returns the global handler to _SandwichCLib. This function performs a lazy initialization of the Sandwich handler.</p> Source code in <code>pysandwich/sandwich.py</code> <pre><code>def sandwich() -&gt; _SandwichCLib:\n\"\"\"Returns the global handler to _SandwichCLib.\n    This function performs a lazy initialization of the Sandwich handler.\n    \"\"\"\nglobal _sandwich_hdl\nif _sandwich_hdl is None:\n_sandwich_hdl = _SandwichCLib()\nreturn _sandwich_hdl\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IO","title":"<code>IO</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstraction of a <code>struct SandwichIO</code> handle.</p> <p>The C handle is built by the tunnel, using the methods from this class.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class IO(abc.ABC):\n\"\"\"Abstraction of a `struct SandwichIO` handle.\n    The C handle is built by the tunnel, using the methods from this class.\n    \"\"\"\nError = SandwichIOProto.IOError\nclass Settings(ctypes.Structure):\n\"\"\"The `struct SandwichIO`.\"\"\"\n# typedef size_t(SandwichIOReadFunction)(void *uarg, void *buf, size_t count,\n# enum SandwichIOError *err);\n_READ_FN_TYPE = ctypes.CFUNCTYPE(\nctypes.c_size_t,  # Return type\nctypes.c_void_p,  # *uarg\nctypes.c_void_p,  # *buf\nctypes.c_size_t,  # count\nctypes.POINTER(ctypes.c_int),  # *err\n)\n# typedef size_t(SandwichIOWriteFunction)(void *uarg, const void *buf,\n# size_t count,\n# enum SandwichIOError *err);\n_WRITE_FN_TYPE = ctypes.CFUNCTYPE(\nctypes.c_size_t,  # Return type\nctypes.c_void_p,  # *uarg\nctypes.c_void_p,  # *buf\nctypes.c_size_t,  # count\nctypes.POINTER(ctypes.c_int),  # *err\n)\n# typedef enum SandwichIOError(SandwichIOFlushFunction)(void *uarg);\n_FLUSH_FN_TYPE = ctypes.CFUNCTYPE(\nctypes.c_int,  # Return type\nctypes.c_void_p,  # *uarg\n)\n_fields_ = [\n(\n\"readfn\",\n_READ_FN_TYPE,\n),\n(\n\"writefn\",\n_WRITE_FN_TYPE,\n),\n(\n\"flushfn\",\n_FLUSH_FN_TYPE,\n),\n(\n\"uarg\",\nctypes.c_void_p,\n),\n]\n@abc.abstractmethod\ndef read(self, n: int) -&gt; bytes:\n\"\"\"Read function.\n        Args:\n            n:\n                Amount of bytes to read.\n        Raises:\n            IOException: an error occured during reading\n        Returns:\n            Bytes successfully read.\n        \"\"\"\nraise NotImplementedError\n@abc.abstractmethod\ndef write(self, buf: bytes) -&gt; int:\n\"\"\"Write function.\n        Args:\n            buf:\n                Buffer to write.\n        Raises:\n            IOException: an error occured during writing\n        Returns:\n            Amount of successfully written bytes.\n        \"\"\"\nraise NotImplementedError\n@abc.abstractmethod\ndef flush(self):\n\"\"\"Flush function.\n        Raises:\n            IOException: an error occured while flushing\n        \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IO.Settings","title":"<code>Settings</code>","text":"<p>             Bases: <code>Structure</code></p> <p>The <code>struct SandwichIO</code>.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class Settings(ctypes.Structure):\n\"\"\"The `struct SandwichIO`.\"\"\"\n# typedef size_t(SandwichIOReadFunction)(void *uarg, void *buf, size_t count,\n# enum SandwichIOError *err);\n_READ_FN_TYPE = ctypes.CFUNCTYPE(\nctypes.c_size_t,  # Return type\nctypes.c_void_p,  # *uarg\nctypes.c_void_p,  # *buf\nctypes.c_size_t,  # count\nctypes.POINTER(ctypes.c_int),  # *err\n)\n# typedef size_t(SandwichIOWriteFunction)(void *uarg, const void *buf,\n# size_t count,\n# enum SandwichIOError *err);\n_WRITE_FN_TYPE = ctypes.CFUNCTYPE(\nctypes.c_size_t,  # Return type\nctypes.c_void_p,  # *uarg\nctypes.c_void_p,  # *buf\nctypes.c_size_t,  # count\nctypes.POINTER(ctypes.c_int),  # *err\n)\n# typedef enum SandwichIOError(SandwichIOFlushFunction)(void *uarg);\n_FLUSH_FN_TYPE = ctypes.CFUNCTYPE(\nctypes.c_int,  # Return type\nctypes.c_void_p,  # *uarg\n)\n_fields_ = [\n(\n\"readfn\",\n_READ_FN_TYPE,\n),\n(\n\"writefn\",\n_WRITE_FN_TYPE,\n),\n(\n\"flushfn\",\n_FLUSH_FN_TYPE,\n),\n(\n\"uarg\",\nctypes.c_void_p,\n),\n]\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IO.flush","title":"<code>flush()</code>  <code>abstractmethod</code>","text":"<p>Flush function.</p> <p>Raises:</p> Type Description <code>IOException</code> <p>an error occured while flushing</p> Source code in <code>pysandwich/io.py</code> <pre><code>@abc.abstractmethod\ndef flush(self):\n\"\"\"Flush function.\n    Raises:\n        IOException: an error occured while flushing\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IO.read","title":"<code>read(n)</code>  <code>abstractmethod</code>","text":"<p>Read function.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Amount of bytes to read.</p> required <p>Raises:</p> Type Description <code>IOException</code> <p>an error occured during reading</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes successfully read.</p> Source code in <code>pysandwich/io.py</code> <pre><code>@abc.abstractmethod\ndef read(self, n: int) -&gt; bytes:\n\"\"\"Read function.\n    Args:\n        n:\n            Amount of bytes to read.\n    Raises:\n        IOException: an error occured during reading\n    Returns:\n        Bytes successfully read.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IO.write","title":"<code>write(buf)</code>  <code>abstractmethod</code>","text":"<p>Write function.</p> <p>Parameters:</p> Name Type Description Default <code>buf</code> <code>bytes</code> <p>Buffer to write.</p> required <p>Raises:</p> Type Description <code>IOException</code> <p>an error occured during writing</p> <p>Returns:</p> Type Description <code>int</code> <p>Amount of successfully written bytes.</p> Source code in <code>pysandwich/io.py</code> <pre><code>@abc.abstractmethod\ndef write(self, buf: bytes) -&gt; int:\n\"\"\"Write function.\n    Args:\n        buf:\n            Buffer to write.\n    Raises:\n        IOException: an error occured during writing\n    Returns:\n        Amount of successfully written bytes.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IOClosedException","title":"<code>IOClosedException</code>","text":"<p>             Bases: <code>IOException</code></p> <p>Closed pipe exception.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class IOClosedException(IOException):\n\"\"\"Closed pipe exception.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(*kargs, code=SandwichIOProto.IOERROR_CLOSED, **kwargs)\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IOException","title":"<code>IOException</code>","text":"<p>             Bases: <code>SandwichException</code></p> <p>Exception base class for I/O interface. Errors are defined in the protobuf <code>io.proto</code>, <code>enum IOError</code>. This exception handles the following cases:     * IOERROR_IN_PROGRESS     * IOERROR_WOULD_BLOCK     * IOERROR_REFUSED     * IOERROR_CLOSED     * IOERROR_INVALID     * IOERROR_UNKNOWN</p> Source code in <code>pysandwich/io.py</code> <pre><code>class IOException(errors.SandwichException):\n\"\"\"Exception base class for I/O interface.\n    Errors are defined in the protobuf `io.proto`, `enum IOError`.\n    This exception handles the following cases:\n        * IOERROR_IN_PROGRESS\n        * IOERROR_WOULD_BLOCK\n        * IOERROR_REFUSED\n        * IOERROR_CLOSED\n        * IOERROR_INVALID\n        * IOERROR_UNKNOWN\n    \"\"\"\n\"\"\"The no-error error.\"\"\"\nERROR_OK = SandwichIOProto.IOERROR_OK\n\"\"\"Map from the protobuf enum `IOError` to error string and subclass exception.\"\"\"\n_ERRORS_MAP = {\nSandwichIOProto.IOERROR_IN_PROGRESS: {\n\"msg\": \"The I/O interface is still connecting to the remote peer\",\n\"cls\": lambda: IOInProgressException,\n},\nSandwichIOProto.IOERROR_WOULD_BLOCK: {\n\"msg\": \"The I/O operation would block, but the I/O interface is non-blocking\",\n\"cls\": lambda: IOWouldBlockException,\n},\nSandwichIOProto.IOERROR_REFUSED: {\n\"msg\": \"The I/O interface has been refused connection\",\n\"cls\": lambda: IORefusedException,\n},\nSandwichIOProto.IOERROR_CLOSED: {\n\"msg\": \"This I/O interface is closed\",\n\"cls\": lambda: IOClosedException,\n},\nSandwichIOProto.IOERROR_INVALID: {\n\"msg\": \"This I/O interface isn't valid\",\n\"cls\": lambda: IOInvalidException,\n},\nSandwichIOProto.IOERROR_UNKNOWN: {\n\"msg\": \"This I/O interface raised an unknown error\",\n\"cls\": lambda: IOUnknownException,\n},\n}\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IOException.ERROR_OK","title":"<code>ERROR_OK = SandwichIOProto.IOERROR_OK</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Map from the protobuf enum <code>IOError</code> to error string and subclass exception.</p>"},{"location":"python_api.html#pysandwich.io.IOInProgressException","title":"<code>IOInProgressException</code>","text":"<p>             Bases: <code>IOException</code></p> <p>In progress exception.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class IOInProgressException(IOException):\n\"\"\"In progress exception.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(*kargs, code=SandwichIOProto.IOERROR_IN_PROGRESS, **kwargs)\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IOInvalidException","title":"<code>IOInvalidException</code>","text":"<p>             Bases: <code>IOException</code></p> <p>Invalid I/O interface exception.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class IOInvalidException(IOException):\n\"\"\"Invalid I/O interface exception.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(*kargs, code=SandwichIOProto.IOERROR_INVALID, **kwargs)\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IORefusedException","title":"<code>IORefusedException</code>","text":"<p>             Bases: <code>IOException</code></p> <p>Connection refused exception.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class IORefusedException(IOException):\n\"\"\"Connection refused exception.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(*kargs, code=SandwichIOProto.IOERROR_REFUSED, **kwargs)\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IOUnknownException","title":"<code>IOUnknownException</code>","text":"<p>             Bases: <code>IOException</code></p> <p>Unknown I/O exception.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class IOUnknownException(IOException):\n\"\"\"Unknown I/O exception.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(*kargs, code=SandwichIOProto.IOERROR_UNKNOWN, **kwargs)\n</code></pre>"},{"location":"python_api.html#pysandwich.io.IOWouldBlockException","title":"<code>IOWouldBlockException</code>","text":"<p>             Bases: <code>IOException</code></p> <p>Would block exception.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class IOWouldBlockException(IOException):\n\"\"\"Would block exception.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(*kargs, code=SandwichIOProto.IOERROR_WOULD_BLOCK, **kwargs)\n</code></pre>"},{"location":"python_api.html#pysandwich.io.OwnedIO","title":"<code>OwnedIO</code>","text":"<p>             Bases: <code>Structure</code></p> <p>The <code>struct SandwichIO</code>.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class OwnedIO(ctypes.Structure):\n\"\"\"The `struct SandwichIO`.\"\"\"\n_IO_TYPE = ctypes.POINTER(IO.Settings)\n# void(SandwhichIOOwnedFreeFunction)(struct SandwhichCIOSettings *cio)\n_FREE_PTR_TYPE = ctypes.CFUNCTYPE(\nNone, ctypes.POINTER(IO.Settings)  # Return type  # cio\n)\n_fields_ = [\n(\n\"io\",\n_IO_TYPE,\n),\n(\n\"freeptr\",\n_FREE_PTR_TYPE,\n),\n]\n</code></pre>"},{"location":"python_api.html#pysandwich.io.TunnelIO","title":"<code>TunnelIO</code>","text":"<p>             Bases: <code>IO</code></p> <p>Abstraction of a <code>struct SandwichTunnelIO</code> handle.</p> <p>The C handle is built by the tunnel, using the methods from this class and <code>SandwichIO</code>.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class TunnelIO(IO):\n\"\"\"Abstraction of a `struct SandwichTunnelIO` handle.\n    The C handle is built by the tunnel, using the methods from this class and\n    `SandwichIO`.\n    \"\"\"\nclass CTunnelIO(ctypes.Structure):\n\"\"\"The `struct SandwichTunnelIO`.\"\"\"\n# typedef void(SandwichTunnelIOSetStateFunction)(void *uarg, enum\n# SandwichTunnelState tunnel_state);\n_SET_STATE_FN_TYPE = ctypes.CFUNCTYPE(\nNone,  # Return type\nctypes.c_void_p,  # *uarg\nctypes.c_int,  # tunnel_state\n)\n_fields_ = [\n(\n\"base\",\nIO.Settings,\n),\n(\n\"set_statefn\",\n_SET_STATE_FN_TYPE,\n),\n]\n@abc.abstractmethod\ndef set_state(self, tunnel_state: SandwichTunnelProto.State):\n\"\"\"Set the state of the tunnel.\n        Args:\n            tunnel_state:\n                Current state of the tunnel.\n        It is guaranteed that the state of the tunnel will not change between\n        two calls to set_state.\n        \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"python_api.html#pysandwich.io.TunnelIO.CTunnelIO","title":"<code>CTunnelIO</code>","text":"<p>             Bases: <code>Structure</code></p> <p>The <code>struct SandwichTunnelIO</code>.</p> Source code in <code>pysandwich/io.py</code> <pre><code>class CTunnelIO(ctypes.Structure):\n\"\"\"The `struct SandwichTunnelIO`.\"\"\"\n# typedef void(SandwichTunnelIOSetStateFunction)(void *uarg, enum\n# SandwichTunnelState tunnel_state);\n_SET_STATE_FN_TYPE = ctypes.CFUNCTYPE(\nNone,  # Return type\nctypes.c_void_p,  # *uarg\nctypes.c_int,  # tunnel_state\n)\n_fields_ = [\n(\n\"base\",\nIO.Settings,\n),\n(\n\"set_statefn\",\n_SET_STATE_FN_TYPE,\n),\n]\n</code></pre>"},{"location":"python_api.html#pysandwich.io.TunnelIO.set_state","title":"<code>set_state(tunnel_state)</code>  <code>abstractmethod</code>","text":"<p>Set the state of the tunnel.</p> <p>Parameters:</p> Name Type Description Default <code>tunnel_state</code> <code>State</code> <p>Current state of the tunnel.</p> required <p>It is guaranteed that the state of the tunnel will not change between two calls to set_state.</p> Source code in <code>pysandwich/io.py</code> <pre><code>@abc.abstractmethod\ndef set_state(self, tunnel_state: SandwichTunnelProto.State):\n\"\"\"Set the state of the tunnel.\n    Args:\n        tunnel_state:\n            Current state of the tunnel.\n    It is guaranteed that the state of the tunnel will not change between\n    two calls to set_state.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.HandshakeErrorStateException","title":"<code>HandshakeErrorStateException</code>","text":"<p>             Bases: <code>HandshakeException</code></p> <p>Handshake general error</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class HandshakeErrorStateException(HandshakeException):\n\"\"\"Handshake general error\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(\n*kargs, code=SandwichTunnelProto.HANDSHAKESTATE_ERROR, **kwargs\n)\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.HandshakeException","title":"<code>HandshakeException</code>","text":"<p>             Bases: <code>SandwichException</code></p> <p>Exception base class for the handshake state. This exception handles the following cases:     * HANDSHAKESTATE_IN_PROGRESS     * HANDSHAKESTATE_WANT_READ     * HANDSHAKESTATE_WANT_WRITE     * HANDSHAKESTATE_ERROR</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class HandshakeException(SandwichException):\n\"\"\"Exception base class for the handshake state.\n    This exception handles the following cases:\n        * HANDSHAKESTATE_IN_PROGRESS\n        * HANDSHAKESTATE_WANT_READ\n        * HANDSHAKESTATE_WANT_WRITE\n        * HANDSHAKESTATE_ERROR\n    \"\"\"\n\"\"\"The no-error error.\"\"\"\nERROR_OK = SandwichTunnelProto.HANDSHAKESTATE_DONE\n\"\"\"Map from the protobuf enum 'HandshakeState\" to error string.\"\"\"\n_ERRORS_MAP = {\nSandwichTunnelProto.HANDSHAKESTATE_IN_PROGRESS: {\n\"msg\": \"The operation is still in progress\",\n\"cls\": lambda: HandshakeInProgressException,\n},\nSandwichTunnelProto.HANDSHAKESTATE_WANT_READ: {\n\"msg\": (\n\"The implementation wants to read from the wire, \"\n\"but the underlying I/O is non-blocking\"\n),\n\"cls\": lambda: HandshakeWantReadException,\n},\nSandwichTunnelProto.HANDSHAKESTATE_WANT_WRITE: {\n\"msg\": (\n\"The implementation wants to write data to the wire, \"\n\"but the underlying I/O is non-blocking\"\n),\n\"cls\": lambda: HandshakeWantWriteException,\n},\nSandwichTunnelProto.HANDSHAKESTATE_ERROR: {\n\"msg\": \"A critical error occurred\",\n\"cls\": lambda: HandshakeErrorStateException,\n},\n}\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.HandshakeException.ERROR_OK","title":"<code>ERROR_OK = SandwichTunnelProto.HANDSHAKESTATE_DONE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Map from the protobuf enum 'HandshakeState\" to error string.</p>"},{"location":"python_api.html#pysandwich.errors.HandshakeInProgressException","title":"<code>HandshakeInProgressException</code>","text":"<p>             Bases: <code>HandshakeException</code></p> <p>Handshake in progress</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class HandshakeInProgressException(HandshakeException):\n\"\"\"Handshake in progress\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(\n*kargs, code=SandwichTunnelProto.HANDSHAKESTATE_IN_PROGRESS, **kwargs\n)\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.HandshakeWantReadException","title":"<code>HandshakeWantReadException</code>","text":"<p>             Bases: <code>HandshakeException</code></p> <p>Handshake wants to read</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class HandshakeWantReadException(HandshakeException):\n\"\"\"Handshake wants to read\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(\n*kargs, code=SandwichTunnelProto.HANDSHAKESTATE_WANT_READ, **kwargs\n)\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.HandshakeWantWriteException","title":"<code>HandshakeWantWriteException</code>","text":"<p>             Bases: <code>HandshakeException</code></p> <p>Handshake wants to write</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class HandshakeWantWriteException(HandshakeException):\n\"\"\"Handshake wants to write\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(\n*kargs, code=SandwichTunnelProto.HANDSHAKESTATE_WANT_WRITE, **kwargs\n)\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.RecordPlaneBeingShutdownException","title":"<code>RecordPlaneBeingShutdownException</code>","text":"<p>             Bases: <code>RecordPlaneException</code></p> <p>Record plane is being closed.</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class RecordPlaneBeingShutdownException(RecordPlaneException):\n\"\"\"Record plane is being closed.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(\n*kargs, code=SandwichTunnelProto.RECORDERROR_BEING_SHUTDOWN, **kwargs\n)\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.RecordPlaneClosedException","title":"<code>RecordPlaneClosedException</code>","text":"<p>             Bases: <code>RecordPlaneException</code></p> <p>Record plane is closed.</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class RecordPlaneClosedException(RecordPlaneException):\n\"\"\"Record plane is closed.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(*kargs, code=SandwichTunnelProto.RECORDERROR_CLOSED, **kwargs)\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.RecordPlaneException","title":"<code>RecordPlaneException</code>","text":"<p>             Bases: <code>SandwichException</code></p> <p>Exception base class for the record plane. Errors are defined in the protobuf, <code>enum RecordError</code>. This exception handles the following cases:     * HANDSHAKESTATE_IN_PROGRESS     * HANDSHAKESTATE_WANT_READ     * HANDSHAKESTATE_WANT_WRITE     * HANDSHAKESTATE_ERROR</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class RecordPlaneException(SandwichException):\n\"\"\"Exception base class for the record plane.\n    Errors are defined in the protobuf, `enum RecordError`.\n    This exception handles the following cases:\n        * HANDSHAKESTATE_IN_PROGRESS\n        * HANDSHAKESTATE_WANT_READ\n        * HANDSHAKESTATE_WANT_WRITE\n        * HANDSHAKESTATE_ERROR\n    \"\"\"\n\"\"\"The no-error error.\"\"\"\nERROR_OK = SandwichTunnelProto.RECORDERROR_OK\n\"\"\"Map from the protobuf enum 'RecordError\" to error string and subclass exception.\"\"\"\n_ERRORS_MAP = {\nSandwichTunnelProto.RECORDERROR_WANT_READ: {\n\"msg\": (\n\"Tunnel wants to read data, but the underlying \"\n\"I/O interface is non-blocking.\"\n),\n\"cls\": lambda: RecordPlaneWantReadException,\n},\nSandwichTunnelProto.RECORDERROR_WANT_WRITE: {\n\"msg\": (\n\"Tunnel wants to write data, but the underlying \"\n\"I/O interface is non-blocking.\"\n),\n\"cls\": lambda: RecordPlaneWantWriteException,\n},\nSandwichTunnelProto.RECORDERROR_BEING_SHUTDOWN: {\n\"msg\": \"Tunnel is being closed\",\n\"cls\": lambda: RecordPlaneBeingShutdownException,\n},\nSandwichTunnelProto.RECORDERROR_CLOSED: {\n\"msg\": \"Tunnel is closed.\",\n\"cls\": lambda: RecordPlaneClosedException,\n},\nSandwichTunnelProto.RECORDERROR_UNKNOWN: {\n\"msg\": \"An unknown error occurred.\",\n\"cls\": lambda: RecordPlaneUnknownErrorException,\n},\n}\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.RecordPlaneException.ERROR_OK","title":"<code>ERROR_OK = SandwichTunnelProto.RECORDERROR_OK</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Map from the protobuf enum 'RecordError\" to error string and subclass exception.</p>"},{"location":"python_api.html#pysandwich.errors.RecordPlaneUnknownErrorException","title":"<code>RecordPlaneUnknownErrorException</code>","text":"<p>             Bases: <code>RecordPlaneException</code></p> <p>An unknown error occurred.</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class RecordPlaneUnknownErrorException(RecordPlaneException):\n\"\"\"An unknown error occurred.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(*kargs, code=SandwichTunnelProto.RECORDERROR_UNKNOWN, **kwargs)\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.RecordPlaneWantReadException","title":"<code>RecordPlaneWantReadException</code>","text":"<p>             Bases: <code>RecordPlaneException</code></p> <p>Record plane wants to read.</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class RecordPlaneWantReadException(RecordPlaneException):\n\"\"\"Record plane wants to read.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(\n*kargs, code=SandwichTunnelProto.RECORDERROR_WANT_READ, **kwargs\n)\n</code></pre>"},{"location":"python_api.html#pysandwich.errors.RecordPlaneWantWriteException","title":"<code>RecordPlaneWantWriteException</code>","text":"<p>             Bases: <code>RecordPlaneException</code></p> <p>Record plane wants to write.</p> Source code in <code>pysandwich/errors.py</code> <pre><code>class RecordPlaneWantWriteException(RecordPlaneException):\n\"\"\"Record plane wants to write.\"\"\"\ndef __init__(self, *kargs, **kwargs):\nsuper().__init__(\n*kargs, code=SandwichTunnelProto.RECORDERROR_WANT_WRITE, **kwargs\n)\n</code></pre>"},{"location":"concepts/io.html","title":"Input/Output (I/O) abstraction","text":"<p>When the Sandwich library needs to transport a stream of data, it does so through a generic I/O interface. Said differently, Sandwich isn't opinionated on the way data should be transported between the peers of a tunnel.</p> <p>The I/O interface has three high-level API calls that are provided by the user:</p> <ul> <li><code>read</code>: read a specified number of bytes for the underlying transport</li> <li><code>write</code>: write a buffer to the underlying transport</li> </ul> <p>It also contains a view of a generic object that can represent any state that is needed to do the actual transport. I/O objects are always owned by a tunnel, giving the ability to the I/O APIs to have access to their parent tunnel, and for instance getting the current state of the tunnel.</p> <p>The I/O interface also supports asynchronous operations, and can return specific error codes for such a purpose.</p>"},{"location":"concepts/io.html#c-api","title":"C API","text":"<p>The I/O interface is described in the C API through the SandwichIO structure.</p> <p>Here is an example of an I/O structure that would forward the data to a socket in C++:</p> <pre><code>/// \\brief Read from a socket.\n///\n/// This method is a SandwichIOReadFunction.\nauto SandwichReadFromSocket(void *uarg, void *buf, const size_t count,\nenum ::SandwichIOError *err) -&gt; size_t {\n*err = SANDWICH_IOERROR_OK;\nconst auto fd = static_cast&lt;int&gt;(reinterpret_cast&lt;uintptr_t&gt;(uarg));\nssize_t r{0};\ndo {\nif (r = ::read(fd, buf, count); r &gt; -1) {\nreturn static_cast&lt;size_t&gt;(r);\n}\n} while ((r == -1) &amp;&amp; (errno == EINTR));\nswitch (errno) {\ncase 0: {\nreturn *err = SANDWICH_IOERROR_OK, 0;\n}\ncase EINPROGRESS:\ncase EINTR: {\nreturn *err = SANDWICH_IOERROR_IN_PROGRESS, 0;\n}\ncase EWOULDBLOCK:\n#if EWOULDBLOCK != EAGAIN\ncase EAGAIN:\n#endif\n{\nreturn *err = SANDWICH_IOERROR_WOULD_BLOCK, 0;\n}\ncase ENOTSOCK:\ncase EPROTOTYPE:\ncase EBADF: {\nreturn *err = SANDWICH_IOERROR_INVALID, 0;\n}\ncase EACCES:\ncase EPERM:\ncase ETIMEDOUT:\ncase ENETUNREACH:\ncase ECONNREFUSED: {\nreturn *err = SANDWICH_IOERROR_REFUSED, 0;\n}\ndefault: {\nreturn *err = SANDWICH_IOERROR_UNKNOWN, 0;\n}\n}\n}\n/// \\brief Write to a socket.\n///\n/// This method is a SandwichIOWriteFunction.\nauto SandwichWriteToSocket(void *uarg, const void *buf, const size_t count,\nenum ::SandwichIOError *err) -&gt; size_t {\n*err = SANDWICH_IOERROR_OK;\nconst auto fd = static_cast&lt;int&gt;(reinterpret_cast&lt;uintptr_t&gt;(uarg));\nssize_t w{0};\ndo {\nif (w = ::write(fd, buf, count); w &gt; -1) {\nreturn static_cast&lt;size_t&gt;(w);\n}\n} while ((w == -1) &amp;&amp; (errno == EINTR));\nswitch (errno) {\ncase 0: {\nreturn *err = SANDWICH_IOERROR_OK, 0;\n}\ncase EINPROGRESS:\ncase EINTR: {\nreturn *err = SANDWICH_IOERROR_WOULD_BLOCK, 0;\n}\ncase ENOTSOCK:\ncase EPROTOTYPE:\ncase EBADF: {\nreturn *err = SANDWICH_IOERROR_INVALID, 0;\n}\ncase EACCES:\ncase EPERM:\ncase ETIMEDOUT:\ncase ENETUNREACH:\ncase ECONNREFUSED: {\nreturn *err = SANDWICH_IOERROR_REFUSED, 0;\n}\ndefault: {\nreturn *err = SANDWICH_IOERROR_UNKNOWN, 0;\n}\n}\n}\n/// \\brief Close a socket.\n///\n/// This method is a SandwichIOCloseFunction.\nvoid CloseSocket(void *uarg) {\nconst auto fd = static_cast&lt;int&gt;(reinterpret_cast&lt;uintptr_t&gt;(uarg));\n::close(fd);\n}\n/// \\brief Global IO interface for sockets.\nconstexpr struct ::SandwichIO SandwichSocketIO = {\n.read = SandwichReadFromSocket,\n.write = SandwichWriteToSocket,\n.uarg = nullptr};\n/// \\brief Global tunnel IO interface for sockets.\nconstexpr struct ::SandwichTunnelIO SandwichSocketTunnelIO {\n.base = SandwichSocketIO, .set_state = nullptr,\n};\n</code></pre>"},{"location":"concepts/io.html#go-api","title":"Go API","text":"<p>Go users need to implement the sandwich.TunnelIO interface. This interface extends the <code>io.ReadWriter</code> go interface.</p>"},{"location":"concepts/tunnel.html","title":"Secure tunnel abstraction","text":""},{"location":"concepts/tunnel.html#introduction","title":"Introduction","text":"<p>Sandwich provides a secure tunnel abstraction. An example of such a tunnel is TLS. Sandwich slices the concept of tunnels into two different states:</p> <ul> <li>a handshake plane where a shared key between two peers is generated</li> <li>a record plane where actual protected data is exchanged</li> </ul> <p>Sandwich uses a protobuf-based configuration for setting up such tunnels. Tunnels are either in client or server mode (from the underlying protocol point of view), depending on whether a ClientOptions or ServerOptions object is used in the overall tunnel configuration. Data are transported over an I/O object that must be initialised before creating a tunnel.</p> <p>The protobuf-based configuration provides various runtime agility:</p> <ul> <li>the cryptography backend that is used for protocol and cryptography   implementation can be changed</li> <li>the actual protocol (client / server)</li> </ul> <p>It provides runtime agility as only the protobuf-based configuration needs to be changed (with no code modification), and that configuration can be provided at runtime. Closing and relaunching existing tunnels is now not done directly by Sandwich, and need to be handled by the users of the library.</p>"},{"location":"concepts/tunnel.html#verifiers","title":"Verifiers","text":"<p>Verifiers are used to verify the identity of the peer a sandwich tunnel is talking with. This is done by passing a TunnelVerifier to the Sandwich tunnel creation API through the TunnelConfiguration message.</p> <p>For TLS, only SAN (Subject Alternative Name) can be verified for now.</p>"},{"location":"concepts/tunnel.html#go-example","title":"Go example","text":"<p>Let's create a TLS server tunnel in Go. First, let's create a protobuf server configuration:</p> <pre><code>import (\nswapi \"github.com/sandbox-quantum/sandwich/go/proto/sandwich/api/v1\"\nsw \"github.com/sandbox-quantum/sandwich/go\"\nswtunnel \"github.com/sandbox-quantum/sandwich/go/tunnel\"\n)\nfunc createServerConfiguration(certfile *string, keyfile *string) *swapi.Configuration {\nreturn &amp;swapi.Configuration{\nImpl: swapi.Implementation_IMPL_OPENSSL1_1_1_OQS,\nOpts: &amp;swapi.Configuration_Server{\nServer: &amp;swapi.ServerOptions{\nOpts: &amp;swapi.ServerOptions_Tls{\nTls: &amp;swapi.TLSServerOptions{\nCommonOptions: &amp;swapi.TLSOptions{\nTls13: &amp;swapi.TLSv13Config{\nCompliance: &amp;swapi.Compliance{\nClassicalChoice: swapi.ClassicalAlgoChoice_CLASSICAL_ALGORITHMS_ALLOW,\n},\nKe: []string{\n\"kyber768\",\n\"p256_kyber512\",\n\"prime256v1\",\n},\n},\nTls12: &amp;swapi.TLSv12Config{\nCiphersuite: []string{\n\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n},\n},\nPeerVerifier: &amp;swapi.TLSOptions_EmptyVerifier{\nEmptyVerifier: &amp;swapi.EmptyVerifier{},\n},\nIdentity: &amp;swapi.X509Identity{\nCertificate: &amp;swapi.Certificate{\nSource: &amp;swapi.Certificate_Static{\nStatic: &amp;swapi.ASN1DataSource{\nData: &amp;swapi.DataSource{\nSpecifier: &amp;swapi.DataSource_Filename{\nFilename: *certfile,\n},\n},\nFormat: swapi.ASN1EncodingFormat_ENCODING_FORMAT_PEM,\n},\n},\n},\nPrivateKey: &amp;swapi.PrivateKey{\nSource: &amp;swapi.PrivateKey_Static{\nStatic: &amp;swapi.ASN1DataSource{\nData: &amp;swapi.DataSource{\nSpecifier: &amp;swapi.DataSource_Filename{\nFilename: *keyfile,\n},\n},\nFormat: swapi.ASN1EncodingFormat_ENCODING_FORMAT_PEM,\n},\n},\n},\n},\n},\n},\n},\n},\n},\n}\n}\n</code></pre> <p>That configuration uses a private key and public certificate that are stored on disk, and accepts <code>kyber768</code>, <code>p256_kyber512</code> and <code>secp256k1</code> as key exchange mechanisms.</p> <p>Assuming we have a valid Sandwich I/O object, we can then create a sandwich tunnel:</p> <pre><code>import (\nswapi \"github.com/sandbox-quantum/sandwich/go/proto/sandwich/api/v1\"\nsw \"github.com/sandbox-quantum/sandwich/go\"\nswtunnel \"github.com/sandbox-quantum/sandwich/go/tunnel\"\n)\n{\nswio := // ...\ntunnel, err := swtunnel.NewTunnelWithReadWriter(ctx, conn, &amp;swapi.TunnelConfiguration{\nVerifier: &amp;swapi.TunnelVerifier{\nVerifier: &amp;swapi.TunnelVerifier_EmptyVerifier{\nEmptyVerifier: &amp;swapi.EmptyVerifier{},\n},\n},\n})\n}\n</code></pre> <p>The underlying I/O object can come for instance from a TCP listener object that has accepted a new connection. An end-to-end example creating an echo TLS server is available in <code>examples/go/echo_tls_server</code>.</p>"},{"location":"concepts/tunnel.html#python-example","title":"Python example","text":"<p>Let's create a TLS server tunnel in Python. First, let's create a protobuf server configuration:</p> <pre><code>import pysandwich.proto.api.v1.compliance_pb2 as Compliance\nimport pysandwich.proto.api.v1.configuration_pb2 as SandwichTunnelProto\nimport pysandwich.proto.api.v1.encoding_format_pb2 as EncodingFormat\nimport pysandwich.proto.api.v1.listener_configuration_pb2 as ListenerAPI\nimport pysandwich.proto.api.v1.verifiers_pb2 as SandwichVerifiers\nimport pysandwich.io_helpers as SandwichIOHelpers\nimport pysandwich.tunnel as SandwichTunnel\nfrom pysandwich.proto.api.v1.tunnel_pb2 import TunnelConfiguration\nfrom pysandwich import listener as SandwichListener\nfrom pysandwich.sandwich import Sandwich\ndef create_server_conf(cert_path: str, key_path: str) -&gt; SandwichTunnelProto:\nconf = SandwichTunnelProto.Configuration()\nconf.impl = SandwichTunnelProto.IMPL_OPENSSL1_1_1_OQS\n# Sets TLS 1.3 Compliance, Key Establishment (KE) and Ciphersuites.\ntls13 = conf.server.tls.common_options.tls13\ntls13.ke.append(\"X25519\")\ntls13.compliance.classical_choice = Compliance.CLASSICAL_ALGORITHMS_ALLOW\n# Sets TLS 1.2 Ciphersuite.\ntls12 = conf.server.tls.common_options.tls12\nciphers = [\n\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n]\ntls12.ciphersuite.extend(ciphers)\nconf.server.tls.common_options.empty_verifier.CopyFrom(\nSandwichVerifiers.EmptyVerifier()\n)\nconf.server.tls.common_options.identity.certificate.static.data.filename = cert_path\nconf.server.tls.common_options.identity.certificate.static.format = (\nEncodingFormat.ENCODING_FORMAT_PEM\n)\nconf.server.tls.common_options.identity.private_key.static.data.filename = key_path\nconf.server.tls.common_options.identity.private_key.static.format = (\nEncodingFormat.ENCODING_FORMAT_PEM\n)\nreturn conf\ndef create_server_tun_conf() -&gt; TunnelConfiguration:\ntun_conf = TunnelConfiguration()\ntun_conf.verifier.empty_verifier.CopyFrom(SandwichVerifiers.EmptyVerifier())\nreturn tun_conf\ndef create_tcp_listener(hostname: str, port: int) -&gt; SandwichListener.Listener:\n\"\"\"Creates the configuration for a TCP listener.\n    Returns:\n        A TCP listener which is listening on hostname:port.\n    \"\"\"\nconf = ListenerAPI.ListenerConfiguration()\nconf.tcp.addr.hostname = hostname\nconf.tcp.addr.port = port\nconf.tcp.blocking_mode = ListenerAPI.BLOCKINGMODE_BLOCKING\nreturn SandwichListener.Listener(conf)\n</code></pre> <p>That configuration uses a private key and public certificate that are stored on disk, and accepts <code>kyber768</code> and <code>prime256v1</code> as key exchange mechanisms.</p> <p>Assuming we have a valid Sandwich I/O object, we can then create a sandwich tunnel:</p> <pre><code>def my_func():\nserver_tun_conf = create_server_tun_conf()\nserver = SandwichTunnel.Tunnel(server_ctx_conf, swio, server_tun_conf)\nserver.handshake()\nstate = server.state()\nassert (\nstate == server.State.STATE_HANDSHAKE_DONE\n), f\"Expected state HANDSHAKE_DONE, got {state}\"\nwhile True:\ndata = b\"\"\nwhile True:\nc = server.read(1)\ndata += c\nif c == b\"\\n\":\nbreak\nserver.write(data)\nserver.close()\nswio = # ...\n</code></pre> <p>An end-to-end example creating an echo TLS server is available in <code>examples/python/echo_tls_server</code>.</p>"},{"location":"examples/echo_tls_server.html","title":"Echo TLS server example","text":"<p>The echo TLS server example implements a TLS server that echos every line it is receiving.</p>"},{"location":"examples/echo_tls_server.html#go-implementation","title":"Go implementation","text":"<p>The server can be run with:</p> <pre><code>$ bazelisk run //examples/go/echo_tls_server:echo_tls_server -- -port 4444 -server_cert /path/to/cert.pem -server_key /path/to/key.pem\n</code></pre> <p>Its source code is the following (<code>examples/go/echo_tls_server/main.go</code>):</p> <pre><code>// Copyright (c) SandboxAQ. All rights reserved.\n// SPDX-License-Identifier: AGPL-3.0-only\npackage main\nimport (\n\"bufio\"\n\"flag\"\n\"fmt\"\n\"io\"\n\"log\"\n\"net\"\n// --8&lt;-- [start:go_imports]\nswapi \"github.com/sandbox-quantum/sandwich/go/proto/sandwich/api/v1\"\nsw \"github.com/sandbox-quantum/sandwich/go\"\nswtunnel \"github.com/sandbox-quantum/sandwich/go/tunnel\"\n// --8&lt;-- [end:go_imports]\n)\n// --8&lt;-- [start:go_server_cfg]\nfunc createServerConfiguration(certfile *string, keyfile *string) *swapi.Configuration {\nreturn &amp;swapi.Configuration{\nImpl: swapi.Implementation_IMPL_OPENSSL1_1_1_OQS,\nOpts: &amp;swapi.Configuration_Server{\nServer: &amp;swapi.ServerOptions{\nOpts: &amp;swapi.ServerOptions_Tls{\nTls: &amp;swapi.TLSServerOptions{\nCommonOptions: &amp;swapi.TLSOptions{\nTls13: &amp;swapi.TLSv13Config{\nCompliance: &amp;swapi.Compliance{\nClassicalChoice: swapi.ClassicalAlgoChoice_CLASSICAL_ALGORITHMS_ALLOW,\n},\nKe: []string{\n\"kyber768\",\n\"p256_kyber512\",\n\"prime256v1\",\n},\n},\nTls12: &amp;swapi.TLSv12Config{\nCiphersuite: []string{\n\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n},\n},\nPeerVerifier: &amp;swapi.TLSOptions_EmptyVerifier{\nEmptyVerifier: &amp;swapi.EmptyVerifier{},\n},\nIdentity: &amp;swapi.X509Identity{\nCertificate: &amp;swapi.Certificate{\nSource: &amp;swapi.Certificate_Static{\nStatic: &amp;swapi.ASN1DataSource{\nData: &amp;swapi.DataSource{\nSpecifier: &amp;swapi.DataSource_Filename{\nFilename: *certfile,\n},\n},\nFormat: swapi.ASN1EncodingFormat_ENCODING_FORMAT_PEM,\n},\n},\n},\nPrivateKey: &amp;swapi.PrivateKey{\nSource: &amp;swapi.PrivateKey_Static{\nStatic: &amp;swapi.ASN1DataSource{\nData: &amp;swapi.DataSource{\nSpecifier: &amp;swapi.DataSource_Filename{\nFilename: *keyfile,\n},\n},\nFormat: swapi.ASN1EncodingFormat_ENCODING_FORMAT_PEM,\n},\n},\n},\n},\n},\n},\n},\n},\n},\n}\n}\n// --8&lt;-- [end:go_server_cfg]\nfunc SWAccept(ctx *swtunnel.TunnelContext, listener net.Listener) (*swtunnel.Tunnel, error) {\nconn, err := listener.Accept()\nif err != nil {\nreturn nil, err\n}\n// --8&lt;-- [start:go_new_tunnel]\ntunnel, err := swtunnel.NewTunnelWithReadWriter(ctx, conn, &amp;swapi.TunnelConfiguration{\nVerifier: &amp;swapi.TunnelVerifier{\nVerifier: &amp;swapi.TunnelVerifier_EmptyVerifier{\nEmptyVerifier: &amp;swapi.EmptyVerifier{},\n},\n},\n})\n// --8&lt;-- [end:go_new_tunnel]\nif err != nil {\nreturn nil, err\n}\nerr = tunnel.Handshake()\nif err != nil {\nreturn nil, err\n}\nreturn tunnel, nil\n}\nfunc handleTunnel(tunnel *swtunnel.Tunnel) {\nreader := bufio.NewReader(tunnel)\nfor {\nbytes, err := reader.ReadBytes(byte('\\n'))\nif err != nil {\nif err != io.EOF {\nlog.Println(\"failed to read data, err:\", err)\n}\nreturn\n}\nfmt.Printf(\"%s\", bytes)\ntunnel.Write(bytes)\n}\n}\nfunc main() {\nserverCert := flag.String(\"server_cert\", \"\", \"Server public certificate\")\nserverKey := flag.String(\"server_key\", \"\", \"Server private key\")\nport := flag.String(\"port\", \"\", \"TCP listening port\")\nhost := flag.String(\"host\", \"127.0.0.1\", \"TCP listening host\")\nflag.Parse()\nif *serverCert == \"\" || *serverKey == \"\" {\nlog.Fatalln(\"Please provide a server certificate and key\")\n}\nif *port == \"\" {\nlog.Fatalln(\"Please provide a server port\")\n}\nsw_lib_ctx := sw.NewSandwich()\nconf := createServerConfiguration(serverCert, serverKey)\ntunnel_ctx, err := swtunnel.NewTunnelContext(sw_lib_ctx, conf)\nif err != nil {\nlog.Fatalln(err)\n}\nlisten, err := net.Listen(\"tcp\", *host+\":\"+*port)\nif err != nil {\nlog.Fatalln(err)\n}\ndefer listen.Close()\nfor {\nconn, err := SWAccept(tunnel_ctx, listen)\nif err != nil {\nlog.Println(err)\ncontinue\n}\ngo handleTunnel(conn)\n}\n}\n</code></pre>"},{"location":"examples/echo_tls_server.html#python-implementation","title":"Python implementation","text":"<p>The server can be run with:</p> <pre><code>$ bazelisk run //examples/python/echo_tls_server:echo_tls_server -- -p 4444 -c /path/to/cert.pem -k /path/to/key.pem\n</code></pre> <p>Its source code is the following (<code>examples/python/echo_tls_server/main.py</code>):</p> <pre><code># Copyright (c) SandboxAQ. All rights reserved.\n# SPDX-License-Identifier: AGPL-3.0-only\n# --8&lt;-- [start:py_imports_proto]\nimport pysandwich.proto.api.v1.compliance_pb2 as Compliance\nimport pysandwich.proto.api.v1.configuration_pb2 as SandwichTunnelProto\nimport pysandwich.proto.api.v1.encoding_format_pb2 as EncodingFormat\nimport pysandwich.proto.api.v1.listener_configuration_pb2 as ListenerAPI\nimport pysandwich.proto.api.v1.verifiers_pb2 as SandwichVerifiers\nimport pysandwich.io_helpers as SandwichIOHelpers\nimport pysandwich.tunnel as SandwichTunnel\nfrom pysandwich.proto.api.v1.tunnel_pb2 import TunnelConfiguration\nfrom pysandwich import listener as SandwichListener\nfrom pysandwich.sandwich import Sandwich\n# --8&lt;-- [end:py_imports_proto]\n# --8&lt;-- [start:py_server_cfg]\ndef create_server_conf(cert_path: str, key_path: str) -&gt; SandwichTunnelProto:\nconf = SandwichTunnelProto.Configuration()\nconf.impl = SandwichTunnelProto.IMPL_OPENSSL1_1_1_OQS\n# Sets TLS 1.3 Compliance, Key Establishment (KE) and Ciphersuites.\ntls13 = conf.server.tls.common_options.tls13\ntls13.ke.append(\"X25519\")\ntls13.compliance.classical_choice = Compliance.CLASSICAL_ALGORITHMS_ALLOW\n# Sets TLS 1.2 Ciphersuite.\ntls12 = conf.server.tls.common_options.tls12\nciphers = [\n\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n]\ntls12.ciphersuite.extend(ciphers)\nconf.server.tls.common_options.empty_verifier.CopyFrom(\nSandwichVerifiers.EmptyVerifier()\n)\nconf.server.tls.common_options.identity.certificate.static.data.filename = cert_path\nconf.server.tls.common_options.identity.certificate.static.format = (\nEncodingFormat.ENCODING_FORMAT_PEM\n)\nconf.server.tls.common_options.identity.private_key.static.data.filename = key_path\nconf.server.tls.common_options.identity.private_key.static.format = (\nEncodingFormat.ENCODING_FORMAT_PEM\n)\nreturn conf\ndef create_server_tun_conf() -&gt; TunnelConfiguration:\ntun_conf = TunnelConfiguration()\ntun_conf.verifier.empty_verifier.CopyFrom(SandwichVerifiers.EmptyVerifier())\nreturn tun_conf\ndef create_tcp_listener(hostname: str, port: int) -&gt; SandwichListener.Listener:\n\"\"\"Creates the configuration for a TCP listener.\n    Returns:\n        A TCP listener which is listening on hostname:port.\n    \"\"\"\nconf = ListenerAPI.ListenerConfiguration()\nconf.tcp.addr.hostname = hostname\nconf.tcp.addr.port = port\nconf.tcp.blocking_mode = ListenerAPI.BLOCKINGMODE_BLOCKING\nreturn SandwichListener.Listener(conf)\n# --8&lt;-- [end:py_server_cfg]\nsw = Sandwich()\ndef server_to_client(server_ctx_conf, swio: SandwichIOHelpers.SwTunnelIOWrapper):\n# --8&lt;-- [start:py_ctx]\nserver_tun_conf = create_server_tun_conf()\nserver = SandwichTunnel.Tunnel(server_ctx_conf, swio, server_tun_conf)\nserver.handshake()\nstate = server.state()\nassert (\nstate == server.State.STATE_HANDSHAKE_DONE\n), f\"Expected state HANDSHAKE_DONE, got {state}\"\nwhile True:\ndata = b\"\"\nwhile True:\nc = server.read(1)\ndata += c\nif c == b\"\\n\":\nbreak\nserver.write(data)\nserver.close()\n# --8&lt;-- [end:py_ctx]\ndef main(hostname: str, port: int, cert: str, key: str):\nserver_ctx_conf = SandwichTunnel.Context.from_config(\nsw, create_server_conf(cert, key)\n)\nlistener = create_tcp_listener(hostname, port)\nlistener.listen()\nwhile True:\nserver_io = listener.accept()\nserver_to_client(server_ctx_conf, server_io)\nif __name__ == \"__main__\":\nimport argparse\nparser = argparse.ArgumentParser(prog=\"Echo TLS server using Sandwich\")\nparser.add_argument(\"-p\", \"--port\", type=int, help=\"Listening port\", required=True)\nparser.add_argument(\"--host\", type=str, help=\"Listening host\", default=\"127.0.0.1\")\nparser.add_argument(\n\"-k\", \"--key\", type=str, help=\"Path to the server private key\", required=True\n)\nparser.add_argument(\n\"-c\",\n\"--cert\",\ntype=str,\nhelp=\"Path to the server public certificate\",\nrequired=True,\n)\nargs = parser.parse_args()\nmain(args.host, args.port, args.cert, args.key)\n</code></pre>"},{"location":"examples/echo_tls_server.html#rust-implementation","title":"Rust implementation","text":"<p>The server can be run with:</p> <pre><code>$ bazelisk run //examples/rust/echo_tls_server:echo_tls_server -- -p 4444 --certificate /path/to/cert.pem --private-key /path/to/key.pem\n</code></pre> <p>Its source code is the following (<code>examples/rust/echo_tls_server/main.rs</code>):</p> <pre><code>\n</code></pre>"},{"location":"examples/tls_client.html","title":"TLS client example","text":"<p>This example creates a netcat-like client for TLS servers using Sandwich. It does not validate any server-side certificates, and should be used for educational purposes only.</p>"},{"location":"examples/tls_client.html#go-implementation","title":"Go implementation","text":"<p>The Go version makes usage of Go channels for an efficient implementation. It can be run with:</p> <pre><code>$ bazelisk run //examples/go/tls_client:tls_client -- -host 127.0.0.1 -port 4444\n</code></pre> <p>Its source code is the following (<code>examples/go/tls_client/main.go</code>):</p> <pre><code>// Copyright (c) SandboxAQ. All rights reserved.\n// SPDX-License-Identifier: AGPL-3.0-only\npackage main\nimport (\n\"flag\"\n\"fmt\"\n\"io\"\n\"log\"\n\"os\"\n\"os/signal\"\n\"syscall\"\nswapi \"github.com/sandbox-quantum/sandwich/go/proto/sandwich/api/v1\"\nsw \"github.com/sandbox-quantum/sandwich/go\"\nswio \"github.com/sandbox-quantum/sandwich/go/io\"\nswtunnel \"github.com/sandbox-quantum/sandwich/go/tunnel\"\n)\nfunc createClientConfiguration(cert *string, tls_version *string) *swapi.Configuration {\nEmptyVerifier := &amp;swapi.TLSOptions_EmptyVerifier{\nEmptyVerifier: &amp;swapi.EmptyVerifier{},\n}\nx509_verifier := &amp;swapi.TLSOptions_X509Verifier{\nX509Verifier: &amp;swapi.X509Verifier{\nTrustedCas: []*swapi.Certificate{\n{\nSource: &amp;swapi.Certificate_Static{\nStatic: &amp;swapi.ASN1DataSource{\nData: &amp;swapi.DataSource{\nSpecifier: &amp;swapi.DataSource_Filename{\nFilename: *cert,\n},\n},\nFormat: swapi.ASN1EncodingFormat_ENCODING_FORMAT_PEM,\n},\n},\n},\n},\n},\n}\nconfig := &amp;swapi.Configuration{\nImpl: swapi.Implementation_IMPL_OPENSSL1_1_1_OQS,\nOpts: &amp;swapi.Configuration_Client{\nClient: &amp;swapi.ClientOptions{\nOpts: &amp;swapi.ClientOptions_Tls{\nTls: &amp;swapi.TLSClientOptions{\nCommonOptions: &amp;swapi.TLSOptions{\nPeerVerifier: &amp;swapi.TLSOptions_EmptyVerifier{\nEmptyVerifier: &amp;swapi.EmptyVerifier{},\n},\n},\n},\n},\n},\n},\n}\ntls13config := &amp;swapi.TLSv13Config{\nCompliance: &amp;swapi.Compliance{\nClassicalChoice: swapi.ClassicalAlgoChoice_CLASSICAL_ALGORITHMS_ALLOW,\n},\nKe: []string{\n\"kyber768\",\n\"p256_kyber512\",\n\"prime256v1\",\n},\n}\ntls12config := &amp;swapi.TLSv12Config{\nCiphersuite: []string{\n\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n},\n}\nswitch *tls_version {\ncase \"tls12\":\nconfig.GetClient().GetTls().CommonOptions.Tls12 = tls12config\ncase \"tls13\":\nconfig.GetClient().GetTls().CommonOptions.Tls13 = tls13config\ndefault:\nlog.Fatalln(\"TLS version is not supported\")\n}\nif len(*cert) == 0 {\nconfig.GetClient().GetTls().CommonOptions.PeerVerifier = EmptyVerifier\n} else {\nconfig.GetClient().GetTls().CommonOptions.PeerVerifier = x509_verifier\n}\nreturn config\n}\nfunc main() {\nhost := flag.String(\"host\", \"\", \"Host to connect to\")\nport := flag.Int64(\"port\", 0, \"TCP port to connect to\")\ntls_version := flag.String(\"tls_version\", \"\", \"TLS version: --tls_version tls13 or tls12\")\ncert := flag.String(\"server_cert\", \"\", \"Server certificates\")\nflag.Parse()\nif *port == 0 || *host == \"\" {\nlog.Fatalln(\"Please provide a client host and port!\")\n}\nif *tls_version == \"\" {\nlog.Fatalln(\"Please provide a TLS protocol version, e.g --tls_version tls13 or tls12\")\n}\nswio, ioerr := swio.IOTCPClient(*host, uint16(*port))\nif ioerr != nil {\nlog.Fatalln(\"Error connecting to destination:\", ioerr)\nreturn\n}\nsw_lib_ctx := sw.NewSandwich()\nctx, err := swtunnel.NewTunnelContext(sw_lib_ctx, createClientConfiguration(cert, tls_version))\nif err != nil {\nlog.Fatalln(\"Error create tunnel context:\", err)\nreturn\n}\ntunnel, err := swtunnel.NewTunnelWithReadWriter(ctx, swio, &amp;swapi.TunnelConfiguration{\nVerifier: &amp;swapi.TunnelVerifier{\nVerifier: &amp;swapi.TunnelVerifier_EmptyVerifier{\nEmptyVerifier: &amp;swapi.EmptyVerifier{},\n},\n},\n})\nif err != nil {\nlog.Fatalln(err)\n}\nerr = tunnel.Handshake()\nif err != nil {\nlog.Fatalln(err)\n}\nerrChannel := make(chan error)\n// Copy data from stdin to destination using io.Copy\ngo func() {\n_, err := io.Copy(tunnel, os.Stdin)\nerrChannel &lt;- err\n}()\n// Copy data from source to stdout using io.Copy\ngo func() {\n_, err := io.Copy(os.Stdout, tunnel)\nerrChannel &lt;- err\n}()\n// Handle Ctrl+C signal to gracefully close the connection\ninterruptChannel := make(chan os.Signal, 1)\nsignal.Notify(interruptChannel, syscall.SIGINT, syscall.SIGTERM)\ngo func() {\n&lt;-interruptChannel\nos.Exit(0)\n}()\n// Wait for the data copying goroutine to finish\nerr = &lt;-errChannel\nif err != nil &amp;&amp; err != io.EOF {\nfmt.Println(\"Error:\", err)\n}\n}\n</code></pre>"},{"location":"examples/tls_client.html#python-implementation","title":"Python implementation","text":"<p>The Python version can be run with:</p> <pre><code>$ bazelisk run //examples/python/tls_client:tls_client -- --host 127.0.0.1 -p 4444\n</code></pre> <p>Its source code is the following (<code>examples/python/tls_client/main.py</code>):</p> <pre><code># Copyright (c) SandboxAQ. All rights reserved.\n# SPDX-License-Identifier: AGPL-3.0-only\nimport selectors\nimport socket\nimport sys\nfrom multiprocessing.connection import Connection\nfrom typing import BinaryIO\nimport pysandwich.proto.api.v1.compliance_pb2 as Compliance\nimport pysandwich.proto.api.v1.configuration_pb2 as SandwichTunnelProto\nimport pysandwich.proto.api.v1.verifiers_pb2 as SandwichVerifiers\nimport pysandwich.errors as SandwichErrors\nimport pysandwich.io_helpers as SandwichIOHelpers\nimport pysandwich.tunnel as SandwichTunnel\nfrom pysandwich.proto.api.v1.tunnel_pb2 import TunnelConfiguration\nfrom pysandwich.sandwich import Sandwich\ndef create_client_conf(tls: str) -&gt; SandwichTunnelProto:\n\"\"\"Create Client configuration.\"\"\"\nconf = SandwichTunnelProto.Configuration()\nconf.impl = SandwichTunnelProto.IMPL_BORINGSSL_OQS\nmatch tls:\ncase \"tls13\":\n# Sets TLS 1.3 Compliance, Key Establishment (KE), and Ciphersuite.\ntls13 = conf.client.tls.common_options.tls13\ntls13.ke.append(\"X25519\")\ntls13.compliance.classical_choice = Compliance.CLASSICAL_ALGORITHMS_ALLOW\ntls13.ciphersuite.extend([\"TLS_CHACHA20_POLY1305_SHA256\"])\ncase \"tls12\":\ntls12 = conf.client.tls.common_options.tls12\nciphers = [\n\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n\"TLS_RSA_WITH_AES_256_GCM_SHA384\",\n\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n\"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n]\ntls12.ciphersuite.extend(ciphers)\ncase _:\nraise NotImplementedError(\"TLS version is not supported\")\nconf.client.tls.common_options.empty_verifier.CopyFrom(\nSandwichVerifiers.EmptyVerifier()\n)\nreturn conf\ndef is_localhost(hostname: str):\ntry:\n# Get the IP address for the given hostname\nip_address = socket.gethostbyname(hostname)\n# Check if the IP address is a localhost IP address\nreturn ip_address in (\"127.0.0.1\", \"::1\")\nexcept socket.gaierror:\n# If the hostname cannot be resolved, it's not localhost\nreturn False\ndef create_client_tun_conf(hostname: str) -&gt; TunnelConfiguration:\ntun_conf = TunnelConfiguration()\nif not is_localhost(hostname):\ntun_conf.server_name_indication = hostname\ntun_conf.verifier.empty_verifier.CopyFrom(SandwichVerifiers.EmptyVerifier())\nreturn tun_conf\ndef run_client(\nhost: str,\nport: int,\ninput_r: Connection | BinaryIO,\noutput_w: Connection | BinaryIO,\nclient_ctx_conf: SandwichTunnel.Context,\n):\n\"\"\"Connect to server with a Context\"\"\"\nwhile True:\ntry:\nclient_io = socket.create_connection((host, port))\nbreak\nexcept ConnectionRefusedError:\npass\nswio = SandwichIOHelpers.io_socket_wrap(client_io)\nclient_tun_conf = create_client_tun_conf(host)\nclient = SandwichTunnel.Tunnel(\nclient_ctx_conf,\nswio,\nclient_tun_conf,\n)\nassert client is not None\nclient.handshake()\nstate = client.state()\nassert (\nstate == client.State.STATE_HANDSHAKE_DONE\n), f\"Expected state HANDSHAKE_DONE, got {state}\"\nsel = selectors.DefaultSelector()\nsel.register(input_r, selectors.EVENT_READ, data=None)\nsel.register(client_io, selectors.EVENT_READ, data=None)\nclient_io.setblocking(False)\nwhile True:\nevents = sel.select(timeout=None)\nfor key, _ in events:\nif key.fileobj is client_io:\ntry:\ndata = client.read(1024)\nexcept SandwichErrors.RecordPlaneWantReadException:\ncontinue\nif not data:\nsel.unregister(client_io)\nelse:\nif isinstance(output_w, Connection):\noutput_w.send_bytes(data)\nelse:\noutput_w.write(b\"&gt;\")\noutput_w.write(data)\noutput_w.flush()\nelif key.fileobj is input_r:\nif isinstance(input_r, Connection):\ndata = input_r.recv_bytes(16)\nelse:\ndata = input_r.readline()\nif not data:\nsel.unregister(input_r)\nelse:\nclient_io.setblocking(True)\nclient.write(data)\nclient_io.setblocking(False)\nclient.close()\ndef main(\nhostname: str,\nport: int,\ntls: str,\ninput_r: Connection | BinaryIO,\noutput_w: Connection | BinaryIO,\n):\nsw = Sandwich()\nclient_conf = create_client_conf(tls)\nclient_ctx = SandwichTunnel.Context.from_config(sw, client_conf)\nrun_client(hostname, port, input_r, output_w, client_ctx)\nif __name__ == \"__main__\":\nimport argparse\nparser = argparse.ArgumentParser(prog=\"TLS client using Sandwich\")\nparser.add_argument(\n\"-p\",\n\"--port\",\ntype=int,\nhelp=\"Port to connect to (defaults to 443)\",\ndefault=443,\nrequired=True,\n)\nparser.add_argument(\"--host\", type=str, help=\"Host to connect to\", required=True)\nparser.add_argument(\n\"--tls_version\",\ntype=str,\nhelp=\"TLS version: --tls_version tls13 or tls12\",\nrequired=True,\n)\nargs = parser.parse_args()\nmain(args.host, args.port, args.tls_version, sys.stdin.buffer, sys.stdout.buffer)\n</code></pre>"},{"location":"examples/tls_client.html#rust-implementation","title":"Rust implementation","text":"<p>The Rust version can be run with:</p> <pre><code>$ bazelisk run //examples/rust/tls_client:tls_client -- --hostname 127.0.0.1 --port 4444\n</code></pre> <p>It only works for Linux so far, as it's using the <code>epoll</code> API.</p> <p>Its source code is the following (<code>examples/rust/tls_client/main.rs</code>):</p> <pre><code>\n</code></pre>"},{"location":"protobuf/index.html","title":"Protocol Buffers API","text":"<p>Sandwich makes use of Protocol Buffers to define different configurations it offers.</p>"},{"location":"protobuf/api/index.html","title":"<code>api</code>","text":"<p>The Sandwich  API is versioned.</p> <p>The current version is <code>v1</code>.</p>"},{"location":"protobuf/api/v1/index.html","title":"<code>api.v1</code>","text":"<p><code>api.v1</code> is the Protobuf package that defines the latest configuration revision (<code>v1</code>).</p>"},{"location":"protobuf/api/v1/index.html#see-also","title":"See also","text":"<ul> <li><code>api.v1.compliance</code></li> <li><code>Configuration</code></li> <li><code>Implementation</code></li> </ul>"},{"location":"protobuf/api/v1/ASN1DataSource.html","title":"ASN1DataSource","text":"<p><code>saq.sandwich.proto.api.v1.ASN1DataSource</code></p>"},{"location":"protobuf/api/v1/ASN1DataSource.html#description","title":"Description","text":"<p>A Data source consisting of ASN.1 encoded data.</p> <p>The data DataSource points to consists of ASN.1 encoded  data. The format of the data is described in  ASN1EncodingFormat.</p> <pre><code>message ASN1DataSource {\n// The raw data source.\n// See [DataSource](DataSource.md).\nDataSource data = 1;\n// The ASN1 encoding format of that data source.\n// See [ASN1EncodingFormat](ASN1EncodingFormat.md).\nASN1EncodingFormat format = 2;\n}\n</code></pre>"},{"location":"protobuf/api/v1/ASN1DataSource.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/ASN1DataSource.html#data","title":"<code>data</code>","text":"<p>The raw data source.  See DataSource.</p> <pre><code>DataSource data = 1;\n</code></pre>"},{"location":"protobuf/api/v1/ASN1DataSource.html#format","title":"<code>format</code>","text":"<p>The ASN1 encoding format of that data source.  See ASN1EncodingFormat.</p> <pre><code>ASN1EncodingFormat format = 2;\n</code></pre>"},{"location":"protobuf/api/v1/ASN1EncodingFormat.html","title":"ASN1EncodingFormat","text":"<p><code>saq.sandwich.proto.api.v1.ASN1EncodingFormat</code></p>"},{"location":"protobuf/api/v1/ASN1EncodingFormat.html#description","title":"Description","text":"<p>Encoding format for ASN.1 data.</p> <p>This format is mainly used to construct an  ASN1DataSource for either a  Certificate or a PrivateKey.</p> <pre><code>enum ASN1EncodingFormat {\n// PEM format.\nENCODING_FORMAT_PEM = 0;\n// DER format.\nENCODING_FORMAT_DER = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/ASN1EncodingFormat.html#values","title":"Values","text":""},{"location":"protobuf/api/v1/ASN1EncodingFormat.html#encoding_format_pem","title":"<code>ENCODING_FORMAT_PEM</code>","text":"<p>PEM format.</p> <pre><code>ENCODING_FORMAT_PEM = 0;\n</code></pre>"},{"location":"protobuf/api/v1/ASN1EncodingFormat.html#encoding_format_der","title":"<code>ENCODING_FORMAT_DER</code>","text":"<p>DER format.</p> <pre><code>ENCODING_FORMAT_DER = 1;\n</code></pre>"},{"location":"protobuf/api/v1/BlockingMode.html","title":"BlockingMode","text":"<p><code>saq.sandwich.proto.api.v1.BlockingMode</code></p>"},{"location":"protobuf/api/v1/BlockingMode.html#description","title":"Description","text":"<p>Blocking mode.</p> <pre><code>enum BlockingMode {\n// Unspecified.\nBLOCKINGMODE_UNSPECIFIED = 0;\n// Blocking mode.\nBLOCKINGMODE_BLOCKING = 1;\n// Non-blocking mode.\nBLOCKINGMODE_NONBLOCKING = 2;\n}\n</code></pre>"},{"location":"protobuf/api/v1/BlockingMode.html#values","title":"Values","text":""},{"location":"protobuf/api/v1/BlockingMode.html#blockingmode_unspecified","title":"<code>BLOCKINGMODE_UNSPECIFIED</code>","text":"<p>Unspecified.</p> <pre><code>BLOCKINGMODE_UNSPECIFIED = 0;\n</code></pre>"},{"location":"protobuf/api/v1/BlockingMode.html#blockingmode_blocking","title":"<code>BLOCKINGMODE_BLOCKING</code>","text":"<p>Blocking mode.</p> <pre><code>BLOCKINGMODE_BLOCKING = 1;\n</code></pre>"},{"location":"protobuf/api/v1/BlockingMode.html#blockingmode_nonblocking","title":"<code>BLOCKINGMODE_NONBLOCKING</code>","text":"<p>Non-blocking mode.</p> <pre><code>BLOCKINGMODE_NONBLOCKING = 2;\n</code></pre>"},{"location":"protobuf/api/v1/Certificate.html","title":"Certificate","text":"<p><code>saq.sandwich.proto.api.v1.Certificate</code></p>"},{"location":"protobuf/api/v1/Certificate.html#description","title":"Description","text":"<p>An X509 certificate.</p> <p>The ASN1DataSource message is used to specify the source  of the certificate.</p> <pre><code>message Certificate {\noneof source {\n// Static source of bytes.\n//\n// See also [ASN1DataSource](ASN1DataSource.md).\nASN1DataSource static = 1;\n}\n}\n</code></pre>"},{"location":"protobuf/api/v1/Certificate.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/Certificate.html#oneof-source","title":"oneof <code>source</code>","text":"<p>no description provided</p> <pre><code>oneof source {\n// Static source of bytes.\n//\n// See also [ASN1DataSource](ASN1DataSource.md).\nASN1DataSource static = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/Certificate.html#static","title":"<code>static</code>","text":"<p>Static source of bytes.</p> <p>See also ASN1DataSource.</p> <pre><code>ASN1DataSource static = 1;\n</code></pre>"},{"location":"protobuf/api/v1/ClassicalAlgoChoice.html","title":"ClassicalAlgoChoice","text":"<p><code>saq.sandwich.proto.api.v1.ClassicalAlgoChoice</code></p>"},{"location":"protobuf/api/v1/ClassicalAlgoChoice.html#description","title":"Description","text":"<p>Whether to allow or forbid classical algorithms. We define \"classical  algorithms\" as something that is not quantum-safe, such as ECC or RSA.</p> <p>By default, classical algorithms are allowed.</p> <p>This enum is part of the Compliance configuration.</p> <p>See also QuantumSafeAlgoChoice and  HybridAlgoChoice.</p> <pre><code>enum ClassicalAlgoChoice {\n// Allows classical algorithms.\nCLASSICAL_ALGORITHMS_ALLOW = 0;\n// Forbids classical algorithms.\nCLASSICAL_ALGORITHMS_FORBID = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/ClassicalAlgoChoice.html#values","title":"Values","text":""},{"location":"protobuf/api/v1/ClassicalAlgoChoice.html#classical_algorithms_allow","title":"<code>CLASSICAL_ALGORITHMS_ALLOW</code>","text":"<p>Allows classical algorithms.</p> <pre><code>CLASSICAL_ALGORITHMS_ALLOW = 0;\n</code></pre>"},{"location":"protobuf/api/v1/ClassicalAlgoChoice.html#classical_algorithms_forbid","title":"<code>CLASSICAL_ALGORITHMS_FORBID</code>","text":"<p>Forbids classical algorithms.</p> <pre><code>CLASSICAL_ALGORITHMS_FORBID = 1;\n</code></pre>"},{"location":"protobuf/api/v1/ClientOptions.html","title":"ClientOptions","text":"<p><code>saq.sandwich.proto.api.v1.ClientOptions</code></p>"},{"location":"protobuf/api/v1/ClientOptions.html#description","title":"Description","text":"<p>Client options.</p> <pre><code>message ClientOptions {\noneof opts {\n// TLS options.\n//\n// See [TLSClientOptions](TLSClientOptions.md).\nTLSClientOptions tls = 1;\n}\n// Next id: 2\n}\n</code></pre>"},{"location":"protobuf/api/v1/ClientOptions.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/ClientOptions.html#oneof-opts","title":"oneof <code>opts</code>","text":"<p>no description provided</p> <pre><code>oneof opts {\n// TLS options.\n//\n// See [TLSClientOptions](TLSClientOptions.md).\nTLSClientOptions tls = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/ClientOptions.html#tls","title":"<code>tls</code>","text":"<p>TLS options.</p> <p>See TLSClientOptions.</p> <pre><code>TLSClientOptions tls = 1;\n</code></pre>"},{"location":"protobuf/api/v1/Compliance.html","title":"Compliance","text":"<p><code>saq.sandwich.proto.api.v1.Compliance</code></p>"},{"location":"protobuf/api/v1/Compliance.html#description","title":"Description","text":"<p><code>Compliance</code> lists high level security constraints on the choice of  algorithms within a Sandwich configuration. If a Sandwich configuration  specifies algorithms that violate those constraints, an error will be  returned.</p> <p>See also:</p> <ul> <li>ClassicalAlgoChoice</li> <li>HybridAlgoChoice</li> <li>NISTSecurityStrengthBits</li> <li>QuantumSafeAlgoChoice</li> </ul> <pre><code>message Compliance {\n// Controls the use of hybrid algorithms. See\n// [HybridAlgoChoice](HybridAlgoChoice.md).\nHybridAlgoChoice hybrid_choice = 1;\n// Controls the use of quantum-safe algorithms.\n// See [QuantumSafeAlgoChoice](QuantumSafeAlgoChoice.md).\nQuantumSafeAlgoChoice quantum_safe_choice = 2;\n// Controls the use of classical algorithms.\n// See [ClassicalAlgoChoice](ClassicalAlgoChoice.md).\nClassicalAlgoChoice classical_choice = 3;\n// Minimum bit strength to enforce.\n// See [NISTSecurityStrengthBits](NISTSecurityStrengthBits.md).\nNISTSecurityStrengthBits bit_strength_choice = 4;\n}\n</code></pre>"},{"location":"protobuf/api/v1/Compliance.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/Compliance.html#hybrid_choice","title":"<code>hybrid_choice</code>","text":"<p>Controls the use of hybrid algorithms. See  HybridAlgoChoice.</p> <pre><code>HybridAlgoChoice hybrid_choice = 1;\n</code></pre>"},{"location":"protobuf/api/v1/Compliance.html#quantum_safe_choice","title":"<code>quantum_safe_choice</code>","text":"<p>Controls the use of quantum-safe algorithms.  See QuantumSafeAlgoChoice.</p> <pre><code>QuantumSafeAlgoChoice quantum_safe_choice = 2;\n</code></pre>"},{"location":"protobuf/api/v1/Compliance.html#classical_choice","title":"<code>classical_choice</code>","text":"<p>Controls the use of classical algorithms.  See ClassicalAlgoChoice.</p> <pre><code>ClassicalAlgoChoice classical_choice = 3;\n</code></pre>"},{"location":"protobuf/api/v1/Compliance.html#bit_strength_choice","title":"<code>bit_strength_choice</code>","text":"<p>Minimum bit strength to enforce.  See NISTSecurityStrengthBits.</p> <pre><code>NISTSecurityStrengthBits bit_strength_choice = 4;\n</code></pre>"},{"location":"protobuf/api/v1/Configuration.html","title":"Configuration","text":"<p><code>saq.sandwich.proto.api.v1.Configuration</code></p>"},{"location":"protobuf/api/v1/Configuration.html#description","title":"Description","text":"<p>A configuration for a sandwich tunnel (either server or client).</p> <pre><code>message Configuration {\n// The implementation to use.\n//\n// See [Implementation](Implementation.md).\nImplementation impl = 1;\n// Options specific to the `{protocol, implementation}` pair.\noneof opts {\n// Client options.\n//\n// See [ClientOptions](ClientOptions.md).\nClientOptions client = 2;\n// Server options.\n// See [ServerOptions](ServerOptions.md).\nServerOptions server = 3;\n}\n// Next id: 5\n}\n</code></pre>"},{"location":"protobuf/api/v1/Configuration.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/Configuration.html#impl","title":"<code>impl</code>","text":"<p>The implementation to use.</p> <p>See Implementation.</p> <pre><code>Implementation impl = 1;\n</code></pre>"},{"location":"protobuf/api/v1/Configuration.html#oneof-opts","title":"oneof <code>opts</code>","text":"<p>Options specific to the <code>{protocol, implementation}</code> pair.</p> <pre><code>oneof opts {\n// Client options.\n//\n// See [ClientOptions](ClientOptions.md).\nClientOptions client = 2;\n// Server options.\n// See [ServerOptions](ServerOptions.md).\nServerOptions server = 3;\n}\n</code></pre>"},{"location":"protobuf/api/v1/Configuration.html#client","title":"<code>client</code>","text":"<p>Client options.</p> <p>See ClientOptions.</p> <pre><code>ClientOptions client = 2;\n</code></pre>"},{"location":"protobuf/api/v1/Configuration.html#server","title":"<code>server</code>","text":"<p>Server options.  See ServerOptions.</p> <pre><code>ServerOptions server = 3;\n</code></pre>"},{"location":"protobuf/api/v1/DataSource.html","title":"DataSource","text":"<p><code>saq.sandwich.proto.api.v1.DataSource</code></p>"},{"location":"protobuf/api/v1/DataSource.html#description","title":"Description","text":"<p>Data source consisting of either a file or an inline value.</p> <pre><code>message DataSource {\noneof specifier {\n// Local filesystem data source.\nstring filename = 1;\n// Bytes inlined in the configuration.\nbytes inline_bytes = 2;\n// String inlined in the configuration.\nstring inline_string = 3;\n}\n}\n</code></pre>"},{"location":"protobuf/api/v1/DataSource.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/DataSource.html#oneof-specifier","title":"oneof <code>specifier</code>","text":"<p>no description provided</p> <pre><code>oneof specifier {\n// Local filesystem data source.\nstring filename = 1;\n// Bytes inlined in the configuration.\nbytes inline_bytes = 2;\n// String inlined in the configuration.\nstring inline_string = 3;\n}\n</code></pre>"},{"location":"protobuf/api/v1/DataSource.html#filename","title":"<code>filename</code>","text":"<p>Local filesystem data source.</p> <pre><code>string filename = 1;\n</code></pre>"},{"location":"protobuf/api/v1/DataSource.html#inline_bytes","title":"<code>inline_bytes</code>","text":"<p>Bytes inlined in the configuration.</p> <pre><code>bytes inline_bytes = 2;\n</code></pre>"},{"location":"protobuf/api/v1/DataSource.html#inline_string","title":"<code>inline_string</code>","text":"<p>String inlined in the configuration.</p> <pre><code>string inline_string = 3;\n</code></pre>"},{"location":"protobuf/api/v1/EmptyVerifier.html","title":"EmptyVerifier","text":"<p><code>saq.sandwich.proto.api.v1.EmptyVerifier</code></p>"},{"location":"protobuf/api/v1/EmptyVerifier.html#description","title":"Description","text":"<p>An empty verifier.</p> <p>An empty verifier is typically used when no verification of the remote  peer is necessary (for instance in a non mutual TLS connection, the server  does not have to verify the client's identity).</p> <p>Warning: if used in a context where a verification may happen, any result will be discarded!</p> <pre><code>message EmptyVerifier {}\n</code></pre>"},{"location":"protobuf/api/v1/EmptyVerifier.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/HybridAlgoChoice.html","title":"HybridAlgoChoice","text":"<p><code>saq.sandwich.proto.api.v1.HybridAlgoChoice</code></p>"},{"location":"protobuf/api/v1/HybridAlgoChoice.html#description","title":"Description","text":"<p>Whether to allow or forbid hybrid algorithms. In this context \"hybrid\" means  a combination of a quantum-safe algorithm and a classical one.</p> <p>By default, hybrid algorithms are allowed.</p> <p>This enum is part of the Compliance configuration.</p> <p>See also ClassicalAlgoChoice and  QuantumSafeAlgoChoice.</p> <pre><code>enum HybridAlgoChoice {\n// Allows hybrid algorithms.\nHYBRID_ALGORITHMS_ALLOW = 0;\n// Forbids hybrid algorithms.\nHYBRID_ALGORITHMS_FORBID = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/HybridAlgoChoice.html#values","title":"Values","text":""},{"location":"protobuf/api/v1/HybridAlgoChoice.html#hybrid_algorithms_allow","title":"<code>HYBRID_ALGORITHMS_ALLOW</code>","text":"<p>Allows hybrid algorithms.</p> <pre><code>HYBRID_ALGORITHMS_ALLOW = 0;\n</code></pre>"},{"location":"protobuf/api/v1/HybridAlgoChoice.html#hybrid_algorithms_forbid","title":"<code>HYBRID_ALGORITHMS_FORBID</code>","text":"<p>Forbids hybrid algorithms.</p> <pre><code>HYBRID_ALGORITHMS_FORBID = 1;\n</code></pre>"},{"location":"protobuf/api/v1/Implementation.html","title":"Implementation","text":"<p><code>saq.sandwich.proto.api.v1.Implementation</code></p>"},{"location":"protobuf/api/v1/Implementation.html#description","title":"Description","text":"<p>Supported implementations.</p> <p>Implementations are low-level cryptographic libraries that Sandwich uses to  provide cryptographic capabilities.</p> <pre><code>enum Implementation {\n// Unspecified implementation.\n// Using this value always leads to an error.\nIMPL_UNSPECIFIED = 0;\n// OpenSSL 1.1.1 with liboqs.\n//\n// See [liboqs](https://github.com/open-quantum-safe/liboqs).\nIMPL_OPENSSL1_1_1_OQS = 1;\n// BoringSSL with liboqs.\n//\n// See [liboqs](https://github.com/open-quantum-safe/liboqs).\nIMPL_BORINGSSL_OQS = 2;\n// OpenSSL 3 with oqs-provider.\n//\n// See [oqs-provider](https://github.com/open-quantum-safe/oqs-provider).\nIMPL_OPENSSL3_OQS_PROVIDER = 3;\n// Next id: 4\n}\n</code></pre>"},{"location":"protobuf/api/v1/Implementation.html#values","title":"Values","text":""},{"location":"protobuf/api/v1/Implementation.html#impl_unspecified","title":"<code>IMPL_UNSPECIFIED</code>","text":"<p>Unspecified implementation.  Using this value always leads to an error.</p> <pre><code>IMPL_UNSPECIFIED = 0;\n</code></pre>"},{"location":"protobuf/api/v1/Implementation.html#impl_openssl1_1_1_oqs","title":"<code>IMPL_OPENSSL1_1_1_OQS</code>","text":"<p>OpenSSL 1.1.1 with liboqs.</p> <p>See liboqs.</p> <pre><code>IMPL_OPENSSL1_1_1_OQS = 1;\n</code></pre>"},{"location":"protobuf/api/v1/Implementation.html#impl_boringssl_oqs","title":"<code>IMPL_BORINGSSL_OQS</code>","text":"<p>BoringSSL with liboqs.</p> <p>See liboqs.</p> <pre><code>IMPL_BORINGSSL_OQS = 2;\n</code></pre>"},{"location":"protobuf/api/v1/Implementation.html#impl_openssl3_oqs_provider","title":"<code>IMPL_OPENSSL3_OQS_PROVIDER</code>","text":"<p>OpenSSL 3 with oqs-provider.</p> <p>See oqs-provider.</p> <pre><code>IMPL_OPENSSL3_OQS_PROVIDER = 3;\n</code></pre>"},{"location":"protobuf/api/v1/ListenerConfiguration.html","title":"ListenerConfiguration","text":"<p><code>saq.sandwich.proto.api.v1.ListenerConfiguration</code></p>"},{"location":"protobuf/api/v1/ListenerConfiguration.html#description","title":"Description","text":"<p>Protobuf configuration for a Sandwich Listener.</p> <pre><code>message ListenerConfiguration {\n// Transport mode.\noneof mode {\n// Standard mode.\nListenerModeTCP tcp = 1;\n// Turbo mode.\nListenerModeTurbo turbo = 2;\n}\n}\n</code></pre>"},{"location":"protobuf/api/v1/ListenerConfiguration.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/ListenerConfiguration.html#oneof-mode","title":"oneof <code>mode</code>","text":"<p>Transport mode.</p> <pre><code>oneof mode {\n// Standard mode.\nListenerModeTCP tcp = 1;\n// Turbo mode.\nListenerModeTurbo turbo = 2;\n}\n</code></pre>"},{"location":"protobuf/api/v1/ListenerConfiguration.html#tcp","title":"<code>tcp</code>","text":"<p>Standard mode.</p> <pre><code>ListenerModeTCP tcp = 1;\n</code></pre>"},{"location":"protobuf/api/v1/ListenerConfiguration.html#turbo","title":"<code>turbo</code>","text":"<p>Turbo mode.</p> <pre><code>ListenerModeTurbo turbo = 2;\n</code></pre>"},{"location":"protobuf/api/v1/ListenerModeTCP.html","title":"ListenerModeTCP","text":"<p><code>saq.sandwich.proto.api.v1.ListenerModeTCP</code></p>"},{"location":"protobuf/api/v1/ListenerModeTCP.html#description","title":"Description","text":"<p>Protobuf configuration for standard mode.</p> <pre><code>message ListenerModeTCP {\n// The socket address.\nSocketAddress addr = 1;\n// Blocking mode.\nBlockingMode blocking_mode = 2;\n}\n</code></pre>"},{"location":"protobuf/api/v1/ListenerModeTCP.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/ListenerModeTCP.html#addr","title":"<code>addr</code>","text":"<p>The socket address.</p> <pre><code>SocketAddress addr = 1;\n</code></pre>"},{"location":"protobuf/api/v1/ListenerModeTCP.html#blocking_mode","title":"<code>blocking_mode</code>","text":"<p>Blocking mode.</p> <pre><code>BlockingMode blocking_mode = 2;\n</code></pre>"},{"location":"protobuf/api/v1/NISTSecurityStrengthBits.html","title":"NISTSecurityStrengthBits","text":"<p><code>saq.sandwich.proto.api.v1.NISTSecurityStrengthBits</code></p>"},{"location":"protobuf/api/v1/NISTSecurityStrengthBits.html#description","title":"Description","text":"<p>The desired security level expressed as \"bit strength\".</p> <p>The default value is 128.</p> <p>This enum is part of the Compliance configuration.</p> <pre><code>enum NISTSecurityStrengthBits {\nBIT_STRENGTH_AT_LEAST_128 = 0;\nBIT_STRENGTH_AT_LEAST_192 = 1;\nBIT_STRENGTH_AT_LEAST_256 = 2;\n}\n</code></pre>"},{"location":"protobuf/api/v1/NISTSecurityStrengthBits.html#values","title":"Values","text":""},{"location":"protobuf/api/v1/NISTSecurityStrengthBits.html#bit_strength_at_least_128","title":"<code>BIT_STRENGTH_AT_LEAST_128</code>","text":"<p>no description provided</p> <pre><code>BIT_STRENGTH_AT_LEAST_128 = 0;\n</code></pre>"},{"location":"protobuf/api/v1/NISTSecurityStrengthBits.html#bit_strength_at_least_192","title":"<code>BIT_STRENGTH_AT_LEAST_192</code>","text":"<p>no description provided</p> <pre><code>BIT_STRENGTH_AT_LEAST_192 = 1;\n</code></pre>"},{"location":"protobuf/api/v1/NISTSecurityStrengthBits.html#bit_strength_at_least_256","title":"<code>BIT_STRENGTH_AT_LEAST_256</code>","text":"<p>no description provided</p> <pre><code>BIT_STRENGTH_AT_LEAST_256 = 2;\n</code></pre>"},{"location":"protobuf/api/v1/PrivateKey.html","title":"PrivateKey","text":"<p><code>saq.sandwich.proto.api.v1.PrivateKey</code></p>"},{"location":"protobuf/api/v1/PrivateKey.html#description","title":"Description","text":"<p>An ASN.1 encoded private key.</p> <p>The ASN1DataSource message is used to specify the source  of the private key..</p> <pre><code>message PrivateKey {\noneof source {\n// Static source of bytes.\n//\n// See also [ASN1DataSource](ASN1DataSource.md).\nASN1DataSource static = 1;\n}\n}\n</code></pre>"},{"location":"protobuf/api/v1/PrivateKey.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/PrivateKey.html#oneof-source","title":"oneof <code>source</code>","text":"<p>no description provided</p> <pre><code>oneof source {\n// Static source of bytes.\n//\n// See also [ASN1DataSource](ASN1DataSource.md).\nASN1DataSource static = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/PrivateKey.html#static","title":"<code>static</code>","text":"<p>Static source of bytes.</p> <p>See also ASN1DataSource.</p> <pre><code>ASN1DataSource static = 1;\n</code></pre>"},{"location":"protobuf/api/v1/QuantumSafeAlgoChoice.html","title":"QuantumSafeAlgoChoice","text":"<p><code>saq.sandwich.proto.api.v1.QuantumSafeAlgoChoice</code></p>"},{"location":"protobuf/api/v1/QuantumSafeAlgoChoice.html#description","title":"Description","text":"<p>Whether to allow or forbid quantum-safe algorithms.</p> <p>By default, quantum-safe algorithms are allowed.</p> <p>This enum is part of the Compliance configuration.</p> <p>See also ClassicalAlgoChoice and  HybridAlgoChoice.</p> <pre><code>enum QuantumSafeAlgoChoice {\n// Allows quantum-safe algorithms.\nQUANTUM_SAFE_ALGORITHMS_ALLOW = 0;\n// Forbids quantum-safe algorithms.\nQUANTUM_SAFE_ALGORITHMS_FORBID = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/QuantumSafeAlgoChoice.html#values","title":"Values","text":""},{"location":"protobuf/api/v1/QuantumSafeAlgoChoice.html#quantum_safe_algorithms_allow","title":"<code>QUANTUM_SAFE_ALGORITHMS_ALLOW</code>","text":"<p>Allows quantum-safe algorithms.</p> <pre><code>QUANTUM_SAFE_ALGORITHMS_ALLOW = 0;\n</code></pre>"},{"location":"protobuf/api/v1/QuantumSafeAlgoChoice.html#quantum_safe_algorithms_forbid","title":"<code>QUANTUM_SAFE_ALGORITHMS_FORBID</code>","text":"<p>Forbids quantum-safe algorithms.</p> <pre><code>QUANTUM_SAFE_ALGORITHMS_FORBID = 1;\n</code></pre>"},{"location":"protobuf/api/v1/SANMatcher.html","title":"SANMatcher","text":"<p><code>saq.sandwich.proto.api.v1.SANMatcher</code></p>"},{"location":"protobuf/api/v1/SANMatcher.html#description","title":"Description","text":"<p>A Subject Alternative Names entry.</p> <pre><code>message SANMatcher {\n// The entry.\noneof san {\n// An email address.\nstring email = 1;\n// An hostname, aka a DNS name.\nstring dns = 2;\n// An IP address.\n//\n// This type allows either an IPv4 address or an IPv6 address.\n// Ranges and masks are not allowed.\nstring ip_address = 3;\n}\n}\n</code></pre>"},{"location":"protobuf/api/v1/SANMatcher.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/SANMatcher.html#oneof-san","title":"oneof <code>san</code>","text":"<p>The entry.</p> <pre><code>oneof san {\n// An email address.\nstring email = 1;\n// An hostname, aka a DNS name.\nstring dns = 2;\n// An IP address.\n//\n// This type allows either an IPv4 address or an IPv6 address.\n// Ranges and masks are not allowed.\nstring ip_address = 3;\n}\n</code></pre>"},{"location":"protobuf/api/v1/SANMatcher.html#email","title":"<code>email</code>","text":"<p>An email address.</p> <pre><code>string email = 1;\n</code></pre>"},{"location":"protobuf/api/v1/SANMatcher.html#dns","title":"<code>dns</code>","text":"<p>An hostname, aka a DNS name.</p> <pre><code>string dns = 2;\n</code></pre>"},{"location":"protobuf/api/v1/SANMatcher.html#ip_address","title":"<code>ip_address</code>","text":"<p>An IP address.</p> <p>This type allows either an IPv4 address or an IPv6 address.  Ranges and masks are not allowed.</p> <pre><code>string ip_address = 3;\n</code></pre>"},{"location":"protobuf/api/v1/SANVerifier.html","title":"SANVerifier","text":"<p><code>saq.sandwich.proto.api.v1.SANVerifier</code></p>"},{"location":"protobuf/api/v1/SANVerifier.html#description","title":"Description","text":"<p>Subject Alternative Names verifier.</p> <p>This verifier is used when a tunnel is created in Sandwich. It is responsible  for verifying that the identity presented by the remote peer matches the  expected identity.</p> <p>This is commonly used to verify the server's name in a TLS connection and  to prevent mallory-in-the-middle attacks.</p> <pre><code>message SANVerifier {\n// Entries of expected Subject Alternative Names.\n//\n// See [SANMatcher](SANMatcher.md).\nrepeated SANMatcher alt_names = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/SANVerifier.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/SANVerifier.html#alt_names","title":"<code>alt_names</code>","text":"<p>Entries of expected Subject Alternative Names.</p> <p>See SANMatcher.</p> <pre><code>repeated SANMatcher alt_names = 1;\n</code></pre>"},{"location":"protobuf/api/v1/ServerOptions.html","title":"ServerOptions","text":"<p><code>saq.sandwich.proto.api.v1.ServerOptions</code></p>"},{"location":"protobuf/api/v1/ServerOptions.html#description","title":"Description","text":"<p>Server options.</p> <pre><code>message ServerOptions {\noneof opts {\n// TLS options.\n//\n// See [TLSServerOptions](TLSServerOptions.md).\nTLSServerOptions tls = 1;\n}\n// Next id: 2\n}\n</code></pre>"},{"location":"protobuf/api/v1/ServerOptions.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/ServerOptions.html#oneof-opts","title":"oneof <code>opts</code>","text":"<p>no description provided</p> <pre><code>oneof opts {\n// TLS options.\n//\n// See [TLSServerOptions](TLSServerOptions.md).\nTLSServerOptions tls = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/ServerOptions.html#tls","title":"<code>tls</code>","text":"<p>TLS options.</p> <p>See TLSServerOptions.</p> <pre><code>TLSServerOptions tls = 1;\n</code></pre>"},{"location":"protobuf/api/v1/SocketAddress.html","title":"SocketAddress","text":"<p><code>saq.sandwich.proto.api.v1.SocketAddress</code></p>"},{"location":"protobuf/api/v1/SocketAddress.html#description","title":"Description","text":"<p>A socket address.</p> <pre><code>message SocketAddress {\n// The hostname.\nstring hostname = 1;\n// The port.\nuint32 port = 2;\n}\n</code></pre>"},{"location":"protobuf/api/v1/SocketAddress.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/SocketAddress.html#hostname","title":"<code>hostname</code>","text":"<p>The hostname.</p> <pre><code>string hostname = 1;\n</code></pre>"},{"location":"protobuf/api/v1/SocketAddress.html#port","title":"<code>port</code>","text":"<p>The port.</p> <pre><code>uint32 port = 2;\n</code></pre>"},{"location":"protobuf/api/v1/TLSClientOptions.html","title":"TLSClientOptions","text":"<p><code>saq.sandwich.proto.api.v1.TLSClientOptions</code></p>"},{"location":"protobuf/api/v1/TLSClientOptions.html#description","title":"Description","text":"<p>TLS options, specific to the client mode.</p> <pre><code>message TLSClientOptions {\n// Common TLS options.\n//\n// See [TLSOptions](TLSOptions.md).\nTLSOptions common_options = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/TLSClientOptions.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/TLSClientOptions.html#common_options","title":"<code>common_options</code>","text":"<p>Common TLS options.</p> <p>See TLSOptions.</p> <pre><code>TLSOptions common_options = 1;\n</code></pre>"},{"location":"protobuf/api/v1/TLSOptions.html","title":"TLSOptions","text":"<p><code>saq.sandwich.proto.api.v1.TLSOptions</code></p>"},{"location":"protobuf/api/v1/TLSOptions.html#description","title":"Description","text":"<p>TLS options, for both client and server modes.</p> <pre><code>message TLSOptions {\n// TLS 1.2 configuration.\n//\n// TLS 1.2 will be disabled if this field is not set.\n// See [`TLSv12Config`](TLSv12Config.md).\nTLSv12Config tls12 = 7;\n// TLS 1.3 configuration.\n//\n// TLS 1.3 will be disabled if this field is not set.\n// See [`TLSv13Config`](TLSv13Config.md).\nTLSv13Config tls13 = 8;\n// The verifier configuration to verify the remote peer.\noneof peer_verifier {\n// Use an X.509 verifier.\n//\n// See [X509Verifier](X509Verifier.md).\nX509Verifier x509_verifier = 3;\n// Use an empty verifier.\n//\n// &gt; **Warning**: when used in a context where a certificate\n// is requested from the remote peer, such as a TLS client or in mTLS,\n// no signature will be verified!\nEmptyVerifier empty_verifier = 4;\n}\n// An identity.\n//\n// In server mode, the identity is used to perform the TLS handshake\n// (the [private key](PrivateKey.md) is used to sign the transcript, and the\n// [certificate](Certificate.md) is presented to clients).\n//\n// See [X509Identity](X509Identity.md).\nX509Identity identity = 5;\n// Application-Layer Protocol Negotiation.\n//\n// This list of strings specifies the different protocols to be negotiated.\nrepeated string alpn_protocols = 6;\n// Next id: 9\n}\n</code></pre>"},{"location":"protobuf/api/v1/TLSOptions.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/TLSOptions.html#tls12","title":"<code>tls12</code>","text":"<p>TLS 1.2 configuration.</p> <p>TLS 1.2 will be disabled if this field is not set.  See <code>TLSv12Config</code>.</p> <pre><code>TLSv12Config tls12 = 7;\n</code></pre>"},{"location":"protobuf/api/v1/TLSOptions.html#tls13","title":"<code>tls13</code>","text":"<p>TLS 1.3 configuration.</p> <p>TLS 1.3 will be disabled if this field is not set.  See <code>TLSv13Config</code>.</p> <pre><code>TLSv13Config tls13 = 8;\n</code></pre>"},{"location":"protobuf/api/v1/TLSOptions.html#oneof-peer_verifier","title":"oneof <code>peer_verifier</code>","text":"<p>The verifier configuration to verify the remote peer.</p> <pre><code>oneof peer_verifier {\n// Use an X.509 verifier.\n//\n// See [X509Verifier](X509Verifier.md).\nX509Verifier x509_verifier = 3;\n// Use an empty verifier.\n//\n// &gt; **Warning**: when used in a context where a certificate\n// is requested from the remote peer, such as a TLS client or in mTLS,\n// no signature will be verified!\nEmptyVerifier empty_verifier = 4;\n}\n</code></pre>"},{"location":"protobuf/api/v1/TLSOptions.html#x509_verifier","title":"<code>x509_verifier</code>","text":"<p>Use an X.509 verifier.</p> <p>See X509Verifier.</p> <pre><code>X509Verifier x509_verifier = 3;\n</code></pre>"},{"location":"protobuf/api/v1/TLSOptions.html#empty_verifier","title":"<code>empty_verifier</code>","text":"<p>Use an empty verifier.</p> <p>Warning: when used in a context where a certificate  is requested from the remote peer, such as a TLS client or in mTLS,  no signature will be verified!</p> <pre><code>EmptyVerifier empty_verifier = 4;\n</code></pre>"},{"location":"protobuf/api/v1/TLSOptions.html#identity","title":"<code>identity</code>","text":"<p>An identity.</p> <p>In server mode, the identity is used to perform the TLS handshake  (the private key is used to sign the transcript, and the  certificate is presented to clients).</p> <p>See X509Identity.</p> <pre><code>X509Identity identity = 5;\n</code></pre>"},{"location":"protobuf/api/v1/TLSOptions.html#alpn_protocols","title":"<code>alpn_protocols</code>","text":"<p>Application-Layer Protocol Negotiation.</p> <p>This list of strings specifies the different protocols to be negotiated.</p> <pre><code>repeated string alpn_protocols = 6;\n</code></pre>"},{"location":"protobuf/api/v1/TLSServerOptions.html","title":"TLSServerOptions","text":"<p><code>saq.sandwich.proto.api.v1.TLSServerOptions</code></p>"},{"location":"protobuf/api/v1/TLSServerOptions.html#description","title":"Description","text":"<p>TLS options, specific to the server mode.</p> <pre><code>message TLSServerOptions {\n// Common TLS options.\n//\n// See [TLSOptions](TLSOptions.md).\nTLSOptions common_options = 1;\n}\n</code></pre>"},{"location":"protobuf/api/v1/TLSServerOptions.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/TLSServerOptions.html#common_options","title":"<code>common_options</code>","text":"<p>Common TLS options.</p> <p>See TLSOptions.</p> <pre><code>TLSOptions common_options = 1;\n</code></pre>"},{"location":"protobuf/api/v1/TLSv12Config.html","title":"TLSv12Config","text":"<p><code>saq.sandwich.proto.api.v1.TLSv12Config</code></p>"},{"location":"protobuf/api/v1/TLSv12Config.html#description","title":"Description","text":"<p>A configuration to constrain ciphersuite for TLS version 1.2.</p> <pre><code>message TLSv12Config {\n// Sets TLS 1.2 ciphersuite.\n//\n// Ciphersuites must follow IANA names.\n//\n// If ciphersuite is **not** set, the default ciphersuites listed here are\n// used in preference order: | Default 256 bits security ciphersuites        |\n// |-----------------------------------------------|\n// | TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384       |\n// | TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 |\n// | TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384         |\n// | TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   |\n// | TLS_RSA_WITH_AES_256_GCM_SHA384               |\n//\n// | Default 128 bits security ciphersuites        |\n// |-----------------------------------------------|\n// | TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256       |\n// | TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256         |\n// | TLS_RSA_WITH_AES_128_GCM_SHA256               |\nrepeated string ciphersuite = 1;\n// Next id: 2\n}\n</code></pre>"},{"location":"protobuf/api/v1/TLSv12Config.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/TLSv12Config.html#ciphersuite","title":"<code>ciphersuite</code>","text":"<p>Sets TLS 1.2 ciphersuite.</p> <p>Ciphersuites must follow IANA names.</p> <p>If ciphersuite is not set, the default ciphersuites listed here are  used in preference order: | Default 256 bits security ciphersuites        |  |-----------------------------------------------|  | TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384       |  | TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 |  | TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384         |  | TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   |  | TLS_RSA_WITH_AES_256_GCM_SHA384               |</p> Default 128 bits security ciphersuites TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_RSA_WITH_AES_128_GCM_SHA256 <pre><code>repeated string ciphersuite = 1;\n</code></pre>"},{"location":"protobuf/api/v1/TLSv13Config.html","title":"TLSv13Config","text":"<p><code>saq.sandwich.proto.api.v1.TLSv13Config</code></p>"},{"location":"protobuf/api/v1/TLSv13Config.html#description","title":"Description","text":"<p>A configuration to constrain Compliance, KEX algorithms and  ciphersuite for TLS version 1.3.</p> <pre><code>message TLSv13Config {\n// Constraints applied on the choice of algorithms in the configuration.\n//\n// See [Compliance](Compliance.md).\nCompliance compliance = 1;\n// The key establishment algorithm (KE) to enforce.\n//\n// If the remote peer does not support at least one KE algorithm specified\n// in this list, the handshake will fail.\n// The order of algorithm in KE is in preference order.\nrepeated string ke = 2;\n// Sets TLS 1.3 ciphersuite.\n//\n// Ciphersuite name must follow IANA name.\n//\n// Does not apply to BoringSSL.\n// See\n// https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration\n//\n// See [RFC 8447 Appendix\n// B.4](https://datatracker.ietf.org/doc/html/rfc8446#appendix-B.4) for the\n// list of supported cipher suites in TLS 1.3.\n//\n// If ciphersuite is **not** set, the default ciphersuites listed here are\n// used in preference order: | Default 256 bits security ciphersuites |\n// |----------------------------------------|\n// | TLS_CHACHA20_POLY1305_SHA256           |\n// | TLS_AES_256_GCM_SHA384                 |\n//\n// | Default 128 bits security ciphersuites |\n// |----------------------------------------|\n// | TLS_AES_128_GCM_SHA256                 |\nrepeated string ciphersuite = 3;\n// Next id: 4\n}\n</code></pre>"},{"location":"protobuf/api/v1/TLSv13Config.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/TLSv13Config.html#compliance","title":"<code>compliance</code>","text":"<p>Constraints applied on the choice of algorithms in the configuration.</p> <p>See Compliance.</p> <pre><code>Compliance compliance = 1;\n</code></pre>"},{"location":"protobuf/api/v1/TLSv13Config.html#ke","title":"<code>ke</code>","text":"<p>The key establishment algorithm (KE) to enforce.</p> <p>If the remote peer does not support at least one KE algorithm specified  in this list, the handshake will fail.  The order of algorithm in KE is in preference order.</p> <pre><code>repeated string ke = 2;\n</code></pre>"},{"location":"protobuf/api/v1/TLSv13Config.html#ciphersuite","title":"<code>ciphersuite</code>","text":"<p>Sets TLS 1.3 ciphersuite.</p> <p>Ciphersuite name must follow IANA name.</p> <p>Does not apply to BoringSSL.  See  https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration</p> <p>See RFC 8447 Appendix  B.4 for the  list of supported cipher suites in TLS 1.3.</p> <p>If ciphersuite is not set, the default ciphersuites listed here are  used in preference order: | Default 256 bits security ciphersuites |  |----------------------------------------|  | TLS_CHACHA20_POLY1305_SHA256           |  | TLS_AES_256_GCM_SHA384                 |</p> Default 128 bits security ciphersuites TLS_AES_128_GCM_SHA256 <pre><code>repeated string ciphersuite = 3;\n</code></pre>"},{"location":"protobuf/api/v1/TunnelConfiguration.html","title":"TunnelConfiguration","text":"<p><code>saq.sandwich.proto.api.v1.TunnelConfiguration</code></p>"},{"location":"protobuf/api/v1/TunnelConfiguration.html#description","title":"Description","text":"<p>Configuration for a tunnel.</p> <p>This configuration is applied at tunnel-time, i.e. when a tunnel is created  from a context.</p> <pre><code>message TunnelConfiguration {\n/// The verifier to use at tunnel-tine.\nTunnelVerifier verifier = 1;\n/// Server name indication (SNI) to set.\nstring server_name_indication = 2;\n}\n</code></pre>"},{"location":"protobuf/api/v1/TunnelConfiguration.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/TunnelConfiguration.html#verifier","title":"<code>verifier</code>","text":"<p>/ The verifier to use at tunnel-tine.</p> <pre><code>TunnelVerifier verifier = 1;\n</code></pre>"},{"location":"protobuf/api/v1/TunnelConfiguration.html#server_name_indication","title":"<code>server_name_indication</code>","text":"<p>/ Server name indication (SNI) to set.</p> <pre><code>string server_name_indication = 2;\n</code></pre>"},{"location":"protobuf/api/v1/TunnelVerifier.html","title":"TunnelVerifier","text":"<p><code>saq.sandwich.proto.api.v1.TunnelVerifier</code></p>"},{"location":"protobuf/api/v1/TunnelVerifier.html#description","title":"Description","text":"<p>Security requirements to enforce at tunnel-time.</p> <p>Unlike the X.509 verifier, which is used when creating a context, this  verifier is used when creating a tunnel. Thus, the security requirements  it describes are enforced to a specific tunnel only.</p> <pre><code>message TunnelVerifier {\n// The verifier to use at tunnel-time.\noneof verifier {\n// Subject Alternative Names verifier, to be used when the TLS protocol is\n// used.\n//\n// See [SANVerifier](SANVerifier.md).\nSANVerifier san_verifier = 1;\n// Empty verifier.\n//\n// &gt; **Warning**: when used, no identity will be verified!\n//\n// See [EmptyVerifier](EmptyVerifier.md).\nEmptyVerifier empty_verifier = 2;\n}\n}\n</code></pre>"},{"location":"protobuf/api/v1/TunnelVerifier.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/TunnelVerifier.html#oneof-verifier","title":"oneof <code>verifier</code>","text":"<p>The verifier to use at tunnel-time.</p> <pre><code>oneof verifier {\n// Subject Alternative Names verifier, to be used when the TLS protocol is\n// used.\n//\n// See [SANVerifier](SANVerifier.md).\nSANVerifier san_verifier = 1;\n// Empty verifier.\n//\n// &gt; **Warning**: when used, no identity will be verified!\n//\n// See [EmptyVerifier](EmptyVerifier.md).\nEmptyVerifier empty_verifier = 2;\n}\n</code></pre>"},{"location":"protobuf/api/v1/TunnelVerifier.html#san_verifier","title":"<code>san_verifier</code>","text":"<p>Subject Alternative Names verifier, to be used when the TLS protocol is  used.</p> <p>See SANVerifier.</p> <pre><code>SANVerifier san_verifier = 1;\n</code></pre>"},{"location":"protobuf/api/v1/TunnelVerifier.html#empty_verifier","title":"<code>empty_verifier</code>","text":"<p>Empty verifier.</p> <p>Warning: when used, no identity will be verified!</p> <p>See EmptyVerifier.</p> <pre><code>EmptyVerifier empty_verifier = 2;\n</code></pre>"},{"location":"protobuf/api/v1/X509Identity.html","title":"X509Identity","text":"<p><code>saq.sandwich.proto.api.v1.X509Identity</code></p>"},{"location":"protobuf/api/v1/X509Identity.html#description","title":"Description","text":"<p>An X.509 identity.</p> <p>It consists of a certificate and its associated  private key.</p> <pre><code>message X509Identity {\n// A certificate or a chain of certificates.\n//\n// The leaf certificate is expected to be the first one if the value points\n// to a chain of certificates.\n//\n// See also [Certificate](Certificate.md).\nCertificate certificate = 1;\n// The private key.\n//\n// See also [PrivateKey](PrivateKey.md).\nPrivateKey private_key = 2;\n// Next id: 3\n}\n</code></pre>"},{"location":"protobuf/api/v1/X509Identity.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/X509Identity.html#certificate","title":"<code>certificate</code>","text":"<p>A certificate or a chain of certificates.</p> <p>The leaf certificate is expected to be the first one if the value points  to a chain of certificates.</p> <p>See also Certificate.</p> <pre><code>Certificate certificate = 1;\n</code></pre>"},{"location":"protobuf/api/v1/X509Identity.html#private_key","title":"<code>private_key</code>","text":"<p>The private key.</p> <p>See also PrivateKey.</p> <pre><code>PrivateKey private_key = 2;\n</code></pre>"},{"location":"protobuf/api/v1/X509Verifier.html","title":"X509Verifier","text":"<p><code>saq.sandwich.proto.api.v1.X509Verifier</code></p>"},{"location":"protobuf/api/v1/X509Verifier.html#description","title":"Description","text":"<p>Verifier for X.509-based protocols such as TLS.</p> <p>When <code>X509Verifier</code> is used as the peer verifier in  TLSOptions, the following security requirements are  enforced:   - Partial certificate chains are forbidden   - CA certificates must include the key usage extension (<code>keyUsage</code>), and   must     have the <code>keyCertSign</code> usage.</p> <p>Some other default parameters are set to be as close as possible to RFC 5280.</p> <pre><code>message X509Verifier {\n// List of trusted certificate authority certificates.\n//\n// Items of this list can also contain several certificates at once.\n// For example, \"/etc/ssl/cert.pem\" usually contains more that one CA. If this\n// file is given, Sandwich will read them all.\n//\n// See [Certificate](Certificate.md).\nrepeated Certificate trusted_cas = 1;\n// Allow expired certificates.\n//\n// If true, no error is returned if an expired certificate is present in the\n// chain of certificates.\n//\n// Default: false.\nbool allow_expired_certificate = 4;\n// Maximum depth of a certificate chain.\n// The leaf certificate is ignored when counting certificates.\n//\n// Default: 100.\nuint32 max_verify_depth = 5;\n// Loads OpenSSL system-default trust anchors CA certificates.\nbool load_cas_from_default_verify_path = 6;\n// Next id: 7\n}\n</code></pre>"},{"location":"protobuf/api/v1/X509Verifier.html#fields","title":"Fields","text":""},{"location":"protobuf/api/v1/X509Verifier.html#trusted_cas","title":"<code>trusted_cas</code>","text":"<p>List of trusted certificate authority certificates.</p> <p>Items of this list can also contain several certificates at once.  For example, \"/etc/ssl/cert.pem\" usually contains more that one CA. If this  file is given, Sandwich will read them all.</p> <p>See Certificate.</p> <pre><code>repeated Certificate trusted_cas = 1;\n</code></pre>"},{"location":"protobuf/api/v1/X509Verifier.html#allow_expired_certificate","title":"<code>allow_expired_certificate</code>","text":"<p>Allow expired certificates.</p> <p>If true, no error is returned if an expired certificate is present in the  chain of certificates.</p> <p>Default: false.</p> <pre><code>bool allow_expired_certificate = 4;\n</code></pre>"},{"location":"protobuf/api/v1/X509Verifier.html#max_verify_depth","title":"<code>max_verify_depth</code>","text":"<p>Maximum depth of a certificate chain.  The leaf certificate is ignored when counting certificates.</p> <p>Default: 100.</p> <pre><code>uint32 max_verify_depth = 5;\n</code></pre>"},{"location":"protobuf/api/v1/X509Verifier.html#load_cas_from_default_verify_path","title":"<code>load_cas_from_default_verify_path</code>","text":"<p>Loads OpenSSL system-default trust anchors CA certificates.</p> <pre><code>bool load_cas_from_default_verify_path = 6;\n</code></pre>"},{"location":"rust_api/sandwich_full_ffi_doc.rustdoc/static.files/SourceSerif4-LICENSE-3bb119e13b1258b7.html","title":"SourceSerif4 LICENSE 3bb119e13b1258b7","text":"<p>Copyright 2014-2021 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries. Copyright 2014 - 2023 Adobe (http://www.adobe.com/), with Reserved Font Name \u2018Source\u2019. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.</p> <p>This Font Software is licensed under the SIL Open Font License, Version 1.1.</p> <p>This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL</p>"},{"location":"rust_api/sandwich_full_ffi_doc.rustdoc/static.files/SourceSerif4-LICENSE-3bb119e13b1258b7.html#sil-open-font-license-version-11-26-february-2007","title":"SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007","text":"<p>PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.</p> <p>The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.</p> <p>DEFINITIONS \"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.</p> <p>\"Reserved Font Name\" refers to any names specified as such after the copyright statement(s).</p> <p>\"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s).</p> <p>\"Modified Version\" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.</p> <p>\"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.</p> <p>PERMISSION &amp; CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:</p> <p>1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.</p> <p>2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.</p> <p>3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.</p> <p>4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.</p> <p>5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.</p> <p>TERMINATION This license becomes null and void if any of the above conditions are not met.</p> <p>DISCLAIMER THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.</p>"},{"location":"cAPI/annotated.html","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct SandwichError An error code. </li> <li>struct SandwichIO A generic I/O interface. </li> <li>struct SandwichIOOwned An IO owned by the Sandwich Library. </li> <li>struct SandwichTunnelConfigurationSerialized A serialized <code>TunnelConfiguration</code> message. </li> <li>struct SandwichTunnelContextConfigurationSerialized A serialized <code>Configuration</code> message. </li> <li>struct SandwichTunnelIO An IO specific to tunnels. </li> </ul>"},{"location":"cAPI/files.html","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir docs <ul> <li>dir sandwich_c <ul> <li>file error.h Error handling for the Sandwich library. </li> <li>file error_codes.h Sandwich errors specification. </li> <li>file export.h </li> <li>file io.h I/O abstraction for Sandwich. </li> <li>file ioerrors.h Sandwich I/O errors specification. </li> <li>file lib.h Top-level context for the Sandwich library. </li> <li>file listener.h Sandwich C library, on top of the Rust implementation. </li> <li>file sandwich.h Sandwich C library, on top of the Rust implementation. </li> <li>file tracer.h Sandwich Tracer API. </li> <li>file tunnel.h Sandwich Tunnel API. </li> <li>file tunnel_types.h Sandwich tunnel types and states specification. </li> </ul> </li> </ul> </li> </ul>"},{"location":"cAPI/structSandwichError.html","title":"Struct SandwichError","text":"<p>ClassList &gt; SandwichError</p> <p>An error code. </p> <ul> <li><code>#include &lt;error.h&gt;</code></li> </ul>"},{"location":"cAPI/structSandwichError.html#public-attributes","title":"Public Attributes","text":"Type Name int code The error code. struct SandwichError * details The encapsulated error. SandwichErrorKind kind The error kind. See error::ErrorKind enum. const char * msg An optional error string."},{"location":"cAPI/structSandwichError.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"cAPI/structSandwichError.html#variable-code","title":"variable code","text":"<pre><code>int SandwichError::code;\n</code></pre>"},{"location":"cAPI/structSandwichError.html#variable-details","title":"variable details","text":"<pre><code>struct SandwichError* SandwichError::details;\n</code></pre>"},{"location":"cAPI/structSandwichError.html#variable-kind","title":"variable kind","text":"<pre><code>SandwichErrorKind SandwichError::kind;\n</code></pre>"},{"location":"cAPI/structSandwichError.html#variable-msg","title":"variable msg","text":"<pre><code>const char* SandwichError::msg;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/error.h</code></p>"},{"location":"cAPI/structSandwichIO.html","title":"Struct SandwichIO","text":"<p>ClassList &gt; SandwichIO</p> <p>A generic I/O interface. </p> <ul> <li><code>#include &lt;io.h&gt;</code></li> </ul>"},{"location":"cAPI/structSandwichIO.html#public-attributes","title":"Public Attributes","text":"Type Name SandwichIOFlushFunctionPtr flush The flush function. SandwichIOReadFunctionPtr read The read function. void * uarg Opaque argument to forward to read, write and flush. SandwichIOWriteFunctionPtr write The write function."},{"location":"cAPI/structSandwichIO.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"cAPI/structSandwichIO.html#variable-flush","title":"variable flush","text":"<p>The flush function. <pre><code>SandwichIOFlushFunctionPtr SandwichIO::flush;\n</code></pre></p> <p><code>NULL</code> is a valid value for flush. </p>"},{"location":"cAPI/structSandwichIO.html#variable-read","title":"variable read","text":"<pre><code>SandwichIOReadFunctionPtr SandwichIO::read;\n</code></pre>"},{"location":"cAPI/structSandwichIO.html#variable-uarg","title":"variable uarg","text":"<pre><code>void* SandwichIO::uarg;\n</code></pre>"},{"location":"cAPI/structSandwichIO.html#variable-write","title":"variable write","text":"<pre><code>SandwichIOWriteFunctionPtr SandwichIO::write;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/io.h</code></p>"},{"location":"cAPI/structSandwichIOOwned.html","title":"Struct SandwichIOOwned","text":"<p>ClassList &gt; SandwichIOOwned</p> <p>An IO owned by the Sandwich Library. More...</p> <ul> <li><code>#include &lt;io.h&gt;</code></li> </ul>"},{"location":"cAPI/structSandwichIOOwned.html#public-attributes","title":"Public Attributes","text":"Type Name SandwichOwnedIOFreeFunctionPtr freeptr The function used to free the owned IO. struct SandwichIO * io The IO which is owned by Sandwich."},{"location":"cAPI/structSandwichIOOwned.html#detailed-description","title":"Detailed Description","text":"<p>SandwichIOOwned objects own the underlying <code>io-&gt;uarg</code> object pointer, and provides a <code>freeptr</code> function that is responsible for destroying that object. SandwichIOOwned must be freed by calling the sandwich_io_owned_free function. This is what is returned from sandwich_io_*_new functions. </p>"},{"location":"cAPI/structSandwichIOOwned.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"cAPI/structSandwichIOOwned.html#variable-freeptr","title":"variable freeptr","text":"<pre><code>SandwichOwnedIOFreeFunctionPtr SandwichIOOwned::freeptr;\n</code></pre>"},{"location":"cAPI/structSandwichIOOwned.html#variable-io","title":"variable io","text":"<pre><code>struct SandwichIO* SandwichIOOwned::io;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/io.h</code></p>"},{"location":"cAPI/structSandwichTunnelConfigurationSerialized.html","title":"Struct SandwichTunnelConfigurationSerialized","text":"<p>ClassList &gt; SandwichTunnelConfigurationSerialized</p> <p>A serialized <code>TunnelConfiguration</code> message.</p> <ul> <li><code>#include &lt;tunnel.h&gt;</code></li> </ul>"},{"location":"cAPI/structSandwichTunnelConfigurationSerialized.html#public-attributes","title":"Public Attributes","text":"Type Name size_t n Size of <code>src</code> . const void * src Buffer containing the serialized <code>TunnelConfiguration</code> message."},{"location":"cAPI/structSandwichTunnelConfigurationSerialized.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"cAPI/structSandwichTunnelConfigurationSerialized.html#variable-n","title":"variable n","text":"<pre><code>size_t SandwichTunnelConfigurationSerialized::n;\n</code></pre>"},{"location":"cAPI/structSandwichTunnelConfigurationSerialized.html#variable-src","title":"variable src","text":"<pre><code>const void* SandwichTunnelConfigurationSerialized::src;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/tunnel.h</code></p>"},{"location":"cAPI/structSandwichTunnelContextConfigurationSerialized.html","title":"Struct SandwichTunnelContextConfigurationSerialized","text":"<p>ClassList &gt; SandwichTunnelContextConfigurationSerialized</p> <p>A serialized <code>Configuration</code> message.</p> <ul> <li><code>#include &lt;tunnel.h&gt;</code></li> </ul>"},{"location":"cAPI/structSandwichTunnelContextConfigurationSerialized.html#public-attributes","title":"Public Attributes","text":"Type Name size_t n Size of <code>src</code> . const void * src Buffer containing the serialized <code>Configuration</code> message."},{"location":"cAPI/structSandwichTunnelContextConfigurationSerialized.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"cAPI/structSandwichTunnelContextConfigurationSerialized.html#variable-n","title":"variable n","text":"<pre><code>size_t SandwichTunnelContextConfigurationSerialized::n;\n</code></pre>"},{"location":"cAPI/structSandwichTunnelContextConfigurationSerialized.html#variable-src","title":"variable src","text":"<pre><code>const void* SandwichTunnelContextConfigurationSerialized::src;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/tunnel.h</code></p>"},{"location":"cAPI/structSandwichTunnelIO.html","title":"Struct SandwichTunnelIO","text":"<p>ClassList &gt; SandwichTunnelIO</p> <p>An IO specific to tunnels. </p> <ul> <li><code>#include &lt;tunnel.h&gt;</code></li> </ul>"},{"location":"cAPI/structSandwichTunnelIO.html#public-attributes","title":"Public Attributes","text":"Type Name struct SandwichIO base The base IO object. SandwichTunnelIOSetStateFunctionPtr set_state The callback used to indicate when the state of the tunnel changes."},{"location":"cAPI/structSandwichTunnelIO.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"cAPI/structSandwichTunnelIO.html#variable-base","title":"variable base","text":"<pre><code>struct SandwichIO SandwichTunnelIO::base;\n</code></pre>"},{"location":"cAPI/structSandwichTunnelIO.html#variable-set_state","title":"variable set_state","text":"<p>The callback used to indicate when the state of the tunnel changes. <pre><code>SandwichTunnelIOSetStateFunctionPtr SandwichTunnelIO::set_state;\n</code></pre></p> <p>It is guaranteed that the state of the tunnel will not change between two calls to this callback.</p> <p><code>NULL</code> is a valid value. </p> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/tunnel.h</code></p>"},{"location":"cAPI/dir_49e56c817e5e54854c35e136979f97ca.html","title":"Dir docs","text":"<p>FileList &gt; docs</p>"},{"location":"cAPI/dir_49e56c817e5e54854c35e136979f97ca.html#directories","title":"Directories","text":"Type Name dir sandwich_c <p>The documentation for this class was generated from the following file <code>docs/</code></p>"},{"location":"cAPI/dir_f6ef5a90171f1138cc160f006fc74f9c.html","title":"Dir docs/sandwich_c","text":"<p>FileList &gt; docs &gt; sandwich_c</p>"},{"location":"cAPI/dir_f6ef5a90171f1138cc160f006fc74f9c.html#files","title":"Files","text":"Type Name file error.h Error handling for the Sandwich library. file error_codes.h Sandwich errors specification. file export.h file io.h I/O abstraction for Sandwich. file ioerrors.h Sandwich I/O errors specification. file lib.h Top-level context for the Sandwich library. file listener.h Sandwich C library, on top of the Rust implementation. file sandwich.h Sandwich C library, on top of the Rust implementation. file tracer.h Sandwich Tracer API. file tunnel.h Sandwich Tunnel API. file tunnel_types.h Sandwich tunnel types and states specification. <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/</code></p>"},{"location":"cAPI/error_8h.html","title":"File error.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; error.h</p> <p>Go to the source code of this file</p> <p>Error handling for the Sandwich library. </p> <ul> <li><code>#include \"sandwich_c/error_codes.h\"</code></li> <li><code>#include \"sandwich_c/export.h\"</code></li> </ul>"},{"location":"cAPI/error_8h.html#classes","title":"Classes","text":"Type Name struct SandwichError An error code."},{"location":"cAPI/error_8h.html#public-functions","title":"Public Functions","text":"Type Name SANDWICH_API void sandwich_error_free (struct SandwichError * chain) Free an error chain. SANDWICH_API void sandwich_error_stack_str_free (const char * err_str) Free a an error string (generated from sandwich_error_stack_str_new) SANDWICH_API char * sandwich_error_stack_str_new (const struct SandwichError * chain) Create an error stack string from a SandwichError chain."},{"location":"cAPI/error_8h.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"cAPI/error_8h.html#function-sandwich_error_free","title":"function sandwich_error_free","text":"<p>Free an error chain. <pre><code>SANDWICH_API void sandwich_error_free (\nstruct SandwichError * chain\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>chain</code> Error chain. </li> </ul>"},{"location":"cAPI/error_8h.html#function-sandwich_error_stack_str_free","title":"function sandwich_error_stack_str_free","text":"<p>Free a an error string (generated from sandwich_error_stack_str_new) <pre><code>SANDWICH_API void sandwich_error_stack_str_free (\nconst char * err_str\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>err_str</code> Pointer to error string to free.</li> </ul> <p>NULL for err_str is allowed. </p>"},{"location":"cAPI/error_8h.html#function-sandwich_error_stack_str_new","title":"function sandwich_error_stack_str_new","text":"<p>Create an error stack string from a SandwichError chain. <pre><code>SANDWICH_API char * sandwich_error_stack_str_new (\nconst struct SandwichError * chain\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>chain</code> Error chain.</li> </ul> <p>Returns:</p> <p>A NUL terminated string describing the SandwichError chain </p> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/error.h</code></p>"},{"location":"cAPI/error_8h_source.html","title":"File error.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; error.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) SandboxAQ. All rights reserved.\n// SPDX-License-Identifier: AGPL-3.0-only\n#pragma once\n#include \"sandwich_c/error_codes.h\"\n#include \"sandwich_c/export.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nstruct SandwichError {\nstruct SandwichError *details;\nconst char *msg;\nSandwichErrorKind kind;\nint code;\n};\nSANDWICH_API void sandwich_error_free(struct SandwichError *chain);\nSANDWICH_API char *\nsandwich_error_stack_str_new(const struct SandwichError *chain);\nSANDWICH_API void sandwich_error_stack_str_free(const char *err_str);\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n</code></pre>"},{"location":"cAPI/error__codes_8h.html","title":"File error_codes.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; error_codes.h</p> <p>Go to the source code of this file</p> <p>Sandwich errors specification. </p>"},{"location":"cAPI/error__codes_8h.html#public-types","title":"Public Types","text":"Type Name enum SandwichALPNError Enum ALPNError. typedef enum SandwichALPNError SandwichALPNError enum SandwichAPIError Enum APIError. typedef enum SandwichAPIError SandwichAPIError enum SandwichASN1Error Enum ASN1Error. typedef enum SandwichASN1Error SandwichASN1Error enum SandwichCertificateError Enum CertificateError. typedef enum SandwichCertificateError SandwichCertificateError enum SandwichConfigurationError Enum ConfigurationError. typedef enum SandwichConfigurationError SandwichConfigurationError enum SandwichDataSourceError Enum DataSourceError. typedef enum SandwichDataSourceError SandwichDataSourceError enum SandwichErrorKind Enum ErrorKind. typedef enum SandwichErrorKind SandwichErrorKind enum SandwichHandshakeError Enum HandshakeError. typedef enum SandwichHandshakeError SandwichHandshakeError enum SandwichKEMError Enum KEMError. typedef enum SandwichKEMError SandwichKEMError enum SandwichPrivateKeyError Enum PrivateKeyError. typedef enum SandwichPrivateKeyError SandwichPrivateKeyError enum SandwichProtobufError Enum ProtobufError. typedef enum SandwichProtobufError SandwichProtobufError enum SandwichSocketError Enum SocketError. typedef enum SandwichSocketError SandwichSocketError enum SandwichSystemError Enum SystemError. typedef enum SandwichSystemError SandwichSystemError enum SandwichTLSConfigurationError Enum TLSConfigurationError. typedef enum SandwichTLSConfigurationError SandwichTLSConfigurationError enum SandwichTunnelError Enum TunnelError. typedef enum SandwichTunnelError SandwichTunnelError"},{"location":"cAPI/error__codes_8h.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"cAPI/error__codes_8h.html#enum-sandwichalpnerror","title":"enum SandwichALPNError","text":"<pre><code>enum SandwichALPNError {\nSANDWICH_ALPNERROR_LENGTH_ERROR = 0,\nSANDWICH_ALPNERROR_INVALID_STRING = 1\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichalpnerror","title":"typedef SandwichALPNError","text":"<pre><code>typedef enum SandwichALPNError SandwichALPNError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichapierror","title":"enum SandwichAPIError","text":"<pre><code>enum SandwichAPIError {\nSANDWICH_APIERROR_CONFIGURATION = 0,\nSANDWICH_APIERROR_SOCKET = 1,\nSANDWICH_APIERROR_TUNNEL = 2\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichapierror","title":"typedef SandwichAPIError","text":"<pre><code>typedef enum SandwichAPIError SandwichAPIError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichasn1error","title":"enum SandwichASN1Error","text":"<pre><code>enum SandwichASN1Error {\nSANDWICH_ASN1ERROR_INVALID_FORMAT = 0,\nSANDWICH_ASN1ERROR_MALFORMED = 1\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichasn1error","title":"typedef SandwichASN1Error","text":"<pre><code>typedef enum SandwichASN1Error SandwichASN1Error;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichcertificateerror","title":"enum SandwichCertificateError","text":"<pre><code>enum SandwichCertificateError {\nSANDWICH_CERTIFICATEERROR_MALFORMED = 0,\nSANDWICH_CERTIFICATEERROR_EXPIRED = 1,\nSANDWICH_CERTIFICATEERROR_NOT_FOUND = 2,\nSANDWICH_CERTIFICATEERROR_UNKNOWN = 3,\nSANDWICH_CERTIFICATEERROR_UNSUPPORTED = 4\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichcertificateerror","title":"typedef SandwichCertificateError","text":"<pre><code>typedef enum SandwichCertificateError SandwichCertificateError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichconfigurationerror","title":"enum SandwichConfigurationError","text":"<pre><code>enum SandwichConfigurationError {\nSANDWICH_CONFIGURATIONERROR_INVALID_IMPLEMENTATION = 0,\nSANDWICH_CONFIGURATIONERROR_UNSUPPORTED_IMPLEMENTATION = 1,\nSANDWICH_CONFIGURATIONERROR_INVALID = 2,\nSANDWICH_CONFIGURATIONERROR_INVALID_LISTENER = 3\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichconfigurationerror","title":"typedef SandwichConfigurationError","text":"<pre><code>typedef enum SandwichConfigurationError SandwichConfigurationError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichdatasourceerror","title":"enum SandwichDataSourceError","text":"<pre><code>enum SandwichDataSourceError {\nSANDWICH_DATASOURCEERROR_EMPTY = 0,\nSANDWICH_DATASOURCEERROR_INVALID_CASE = 1,\nSANDWICH_DATASOURCEERROR_NOT_FOUND = 2\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichdatasourceerror","title":"typedef SandwichDataSourceError","text":"<pre><code>typedef enum SandwichDataSourceError SandwichDataSourceError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwicherrorkind","title":"enum SandwichErrorKind","text":"<pre><code>enum SandwichErrorKind {\nSANDWICH_ERRORKIND_API = 0,\nSANDWICH_ERRORKIND_CONFIGURATION = 1,\nSANDWICH_ERRORKIND_TLS_CONFIGURATION = 2,\nSANDWICH_ERRORKIND_CERTIFICATE = 3,\nSANDWICH_ERRORKIND_SYSTEM = 4,\nSANDWICH_ERRORKIND_SOCKET = 5,\nSANDWICH_ERRORKIND_PROTOBUF = 6,\nSANDWICH_ERRORKIND_PRIVATE_KEY = 7,\nSANDWICH_ERRORKIND_ASN1 = 8,\nSANDWICH_ERRORKIND_DATA_SOURCE = 9,\nSANDWICH_ERRORKIND_KEM = 10,\nSANDWICH_ERRORKIND_HANDSHAKE = 11,\nSANDWICH_ERRORKIND_TUNNEL = 12,\nSANDWICH_ERRORKIND_ALPN = 13,\nSANDWICH_ERRORKIND_IO = 14\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwicherrorkind","title":"typedef SandwichErrorKind","text":"<pre><code>typedef enum SandwichErrorKind SandwichErrorKind;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichhandshakeerror","title":"enum SandwichHandshakeError","text":"<pre><code>enum SandwichHandshakeError {\nSANDWICH_HANDSHAKEERROR_INVALID_SERVER_NAME = 0,\nSANDWICH_HANDSHAKEERROR_CERTIFICATE_VERIFICATION_FAILED = 1,\nSANDWICH_HANDSHAKEERROR_CERTIFICATE_EXPIRED = 2,\nSANDWICH_HANDSHAKEERROR_CERTIFICATE_REVOKED = 3,\nSANDWICH_HANDSHAKEERROR_INVALID_CERTIFICATE = 4,\nSANDWICH_HANDSHAKEERROR_CERTIFICATE_SIGNATURE_VERIFICATION_FAILED = 5,\nSANDWICH_HANDSHAKEERROR_UNKNOWN_ERROR = 6,\nSANDWICH_HANDSHAKEERROR_DEPTH_EXCEEDED = 7,\nSANDWICH_HANDSHAKEERROR_UNSUPPORTED_PROTOCOL = 8,\nSANDWICH_HANDSHAKEERROR_NO_SHARED_CIPHER = 9,\nSANDWICH_HANDSHAKEERROR_NO_SUITABLE_KEY_SHARE = 10\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichhandshakeerror","title":"typedef SandwichHandshakeError","text":"<pre><code>typedef enum SandwichHandshakeError SandwichHandshakeError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichkemerror","title":"enum SandwichKEMError","text":"<pre><code>enum SandwichKEMError {\nSANDWICH_KEMERROR_INVALID = 0,\nSANDWICH_KEMERROR_TOO_MANY = 1\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichkemerror","title":"typedef SandwichKEMError","text":"<pre><code>typedef enum SandwichKEMError SandwichKEMError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichprivatekeyerror","title":"enum SandwichPrivateKeyError","text":"<pre><code>enum SandwichPrivateKeyError {\nSANDWICH_PRIVATEKEYERROR_MALFORMED = 0,\nSANDWICH_PRIVATEKEYERROR_NOT_FOUND = 1,\nSANDWICH_PRIVATEKEYERROR_UNKNOWN = 2,\nSANDWICH_PRIVATEKEYERROR_UNSUPPORTED = 3,\nSANDWICH_PRIVATEKEYERROR_NOT_SERVER = 4\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichprivatekeyerror","title":"typedef SandwichPrivateKeyError","text":"<pre><code>typedef enum SandwichPrivateKeyError SandwichPrivateKeyError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichprotobuferror","title":"enum SandwichProtobufError","text":"<pre><code>enum SandwichProtobufError {\nSANDWICH_PROTOBUFERROR_EMPTY = 0,\nSANDWICH_PROTOBUFERROR_TOO_BIG = 1,\nSANDWICH_PROTOBUFERROR_PARSE_FAILED = 2,\nSANDWICH_PROTOBUFERROR_NULLPTR = 3,\nSANDWICH_PROTOBUFERROR_INVALID_ARGUMENT = 4\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichprotobuferror","title":"typedef SandwichProtobufError","text":"<pre><code>typedef enum SandwichProtobufError SandwichProtobufError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichsocketerror","title":"enum SandwichSocketError","text":"<pre><code>enum SandwichSocketError {\nSANDWICH_SOCKETERROR_BAD_FD = 0,\nSANDWICH_SOCKETERROR_CREATION_FAILED = 1,\nSANDWICH_SOCKETERROR_BAD_NETADDR = 2,\nSANDWICH_SOCKETERROR_NETADDR_UNKNOWN = 3,\nSANDWICH_SOCKETERROR_FSTAT_FAILED = 4,\nSANDWICH_SOCKETERROR_NOT_SOCK = 5,\nSANDWICH_SOCKETERROR_GETSOCKNAME_FAILED = 6,\nSANDWICH_SOCKETERROR_SETSOCKOPT_FAILED = 7,\nSANDWICH_SOCKETERROR_INVALID_AI_FAMILY = 8\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichsocketerror","title":"typedef SandwichSocketError","text":"<pre><code>typedef enum SandwichSocketError SandwichSocketError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichsystemerror","title":"enum SandwichSystemError","text":"<pre><code>enum SandwichSystemError {\nSANDWICH_SYSTEMERROR_MEMORY = 0,\nSANDWICH_SYSTEMERROR_INTEGER_OVERFLOW = 1,\nSANDWICH_SYSTEMERROR_BACKEND = 2\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichsystemerror","title":"typedef SandwichSystemError","text":"<pre><code>typedef enum SandwichSystemError SandwichSystemError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichtlsconfigurationerror","title":"enum SandwichTLSConfigurationError","text":"<pre><code>enum SandwichTLSConfigurationError {\nSANDWICH_TLSCONFIGURATIONERROR_UNSUPPORTED_IMPLEMENTATION = 0,\nSANDWICH_TLSCONFIGURATIONERROR_INVALID_CASE = 1,\nSANDWICH_TLSCONFIGURATIONERROR_EMPTY = 2,\nSANDWICH_TLSCONFIGURATIONERROR_UNSUPPORTED_PROTOCOL_VERSION = 3,\nSANDWICH_TLSCONFIGURATIONERROR_PRIVATE_KEY_INCONSISTENT_WITH_CERTIFICATE = 4,\nSANDWICH_TLSCONFIGURATIONERROR_INVALID = 5,\nSANDWICH_TLSCONFIGURATIONERROR_UNSUPPORTED_CIPHERSUITE = 6,\nSANDWICH_TLSCONFIGURATIONERROR_UNSUPPORTED_CONTROL_CHARACTERS = 7\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichtlsconfigurationerror","title":"typedef SandwichTLSConfigurationError","text":"<pre><code>typedef enum SandwichTLSConfigurationError SandwichTLSConfigurationError;\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#enum-sandwichtunnelerror","title":"enum SandwichTunnelError","text":"<pre><code>enum SandwichTunnelError {\nSANDWICH_TUNNELERROR_INVALID = 0,\nSANDWICH_TUNNELERROR_VERIFIER = 1,\nSANDWICH_TUNNELERROR_UNKNOWN = 2\n};\n</code></pre>"},{"location":"cAPI/error__codes_8h.html#typedef-sandwichtunnelerror","title":"typedef SandwichTunnelError","text":"<pre><code>typedef enum SandwichTunnelError SandwichTunnelError;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/error_codes.h</code></p>"},{"location":"cAPI/error__codes_8h_source.html","title":"File error_codes.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; error_codes.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 SandboxAQ\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#pragma once\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nenum SandwichAPIError { SANDWICH_APIERROR_CONFIGURATION = 0,\nSANDWICH_APIERROR_SOCKET = 1,\nSANDWICH_APIERROR_TUNNEL = 2,\n};\ntypedef enum SandwichAPIError SandwichAPIError;\nenum SandwichConfigurationError { SANDWICH_CONFIGURATIONERROR_INVALID_IMPLEMENTATION = 0,\nSANDWICH_CONFIGURATIONERROR_UNSUPPORTED_IMPLEMENTATION = 1,\nSANDWICH_CONFIGURATIONERROR_INVALID = 2,\nSANDWICH_CONFIGURATIONERROR_INVALID_LISTENER = 3,\n};\ntypedef enum SandwichConfigurationError SandwichConfigurationError;\nenum SandwichProtobufError { SANDWICH_PROTOBUFERROR_EMPTY = 0,\nSANDWICH_PROTOBUFERROR_TOO_BIG = 1,\nSANDWICH_PROTOBUFERROR_PARSE_FAILED = 2,\nSANDWICH_PROTOBUFERROR_NULLPTR = 3,\nSANDWICH_PROTOBUFERROR_INVALID_ARGUMENT = 4,\n};\ntypedef enum SandwichProtobufError SandwichProtobufError;\nenum SandwichTLSConfigurationError { SANDWICH_TLSCONFIGURATIONERROR_UNSUPPORTED_IMPLEMENTATION = 0,\nSANDWICH_TLSCONFIGURATIONERROR_INVALID_CASE = 1,\nSANDWICH_TLSCONFIGURATIONERROR_EMPTY = 2,\nSANDWICH_TLSCONFIGURATIONERROR_UNSUPPORTED_PROTOCOL_VERSION = 3,\nSANDWICH_TLSCONFIGURATIONERROR_PRIVATE_KEY_INCONSISTENT_WITH_CERTIFICATE = 4,\nSANDWICH_TLSCONFIGURATIONERROR_INVALID = 5,\nSANDWICH_TLSCONFIGURATIONERROR_UNSUPPORTED_CIPHERSUITE = 6,\nSANDWICH_TLSCONFIGURATIONERROR_UNSUPPORTED_CONTROL_CHARACTERS = 7,\n};\ntypedef enum SandwichTLSConfigurationError SandwichTLSConfigurationError;\nenum SandwichCertificateError { SANDWICH_CERTIFICATEERROR_MALFORMED = 0,\nSANDWICH_CERTIFICATEERROR_EXPIRED = 1,\nSANDWICH_CERTIFICATEERROR_NOT_FOUND = 2,\nSANDWICH_CERTIFICATEERROR_UNKNOWN = 3,\nSANDWICH_CERTIFICATEERROR_UNSUPPORTED = 4,\n};\ntypedef enum SandwichCertificateError SandwichCertificateError;\nenum SandwichPrivateKeyError { SANDWICH_PRIVATEKEYERROR_MALFORMED = 0,\nSANDWICH_PRIVATEKEYERROR_NOT_FOUND = 1,\nSANDWICH_PRIVATEKEYERROR_UNKNOWN = 2,\nSANDWICH_PRIVATEKEYERROR_UNSUPPORTED = 3,\nSANDWICH_PRIVATEKEYERROR_NOT_SERVER = 4,\n};\ntypedef enum SandwichPrivateKeyError SandwichPrivateKeyError;\nenum SandwichASN1Error { SANDWICH_ASN1ERROR_INVALID_FORMAT = 0,\nSANDWICH_ASN1ERROR_MALFORMED = 1,\n};\ntypedef enum SandwichASN1Error SandwichASN1Error;\nenum SandwichALPNError { SANDWICH_ALPNERROR_LENGTH_ERROR = 0,\nSANDWICH_ALPNERROR_INVALID_STRING = 1,\n};\ntypedef enum SandwichALPNError SandwichALPNError;\nenum SandwichDataSourceError { SANDWICH_DATASOURCEERROR_EMPTY = 0,\nSANDWICH_DATASOURCEERROR_INVALID_CASE = 1,\nSANDWICH_DATASOURCEERROR_NOT_FOUND = 2,\n};\ntypedef enum SandwichDataSourceError SandwichDataSourceError;\nenum SandwichKEMError { SANDWICH_KEMERROR_INVALID = 0,\nSANDWICH_KEMERROR_TOO_MANY = 1,\n};\ntypedef enum SandwichKEMError SandwichKEMError;\nenum SandwichSystemError { SANDWICH_SYSTEMERROR_MEMORY = 0,\nSANDWICH_SYSTEMERROR_INTEGER_OVERFLOW = 1,\nSANDWICH_SYSTEMERROR_BACKEND = 2,\n};\ntypedef enum SandwichSystemError SandwichSystemError;\nenum SandwichSocketError { SANDWICH_SOCKETERROR_BAD_FD = 0,\nSANDWICH_SOCKETERROR_CREATION_FAILED = 1,\nSANDWICH_SOCKETERROR_BAD_NETADDR = 2,\nSANDWICH_SOCKETERROR_NETADDR_UNKNOWN = 3,\nSANDWICH_SOCKETERROR_FSTAT_FAILED = 4,\nSANDWICH_SOCKETERROR_NOT_SOCK = 5,\nSANDWICH_SOCKETERROR_GETSOCKNAME_FAILED = 6,\nSANDWICH_SOCKETERROR_SETSOCKOPT_FAILED = 7,\nSANDWICH_SOCKETERROR_INVALID_AI_FAMILY = 8,\n};\ntypedef enum SandwichSocketError SandwichSocketError;\nenum SandwichHandshakeError { SANDWICH_HANDSHAKEERROR_INVALID_SERVER_NAME = 0,\nSANDWICH_HANDSHAKEERROR_CERTIFICATE_VERIFICATION_FAILED = 1,\nSANDWICH_HANDSHAKEERROR_CERTIFICATE_EXPIRED = 2,\nSANDWICH_HANDSHAKEERROR_CERTIFICATE_REVOKED = 3,\nSANDWICH_HANDSHAKEERROR_INVALID_CERTIFICATE = 4,\nSANDWICH_HANDSHAKEERROR_CERTIFICATE_SIGNATURE_VERIFICATION_FAILED = 5,\nSANDWICH_HANDSHAKEERROR_UNKNOWN_ERROR = 6,\nSANDWICH_HANDSHAKEERROR_DEPTH_EXCEEDED = 7,\nSANDWICH_HANDSHAKEERROR_UNSUPPORTED_PROTOCOL = 8,\nSANDWICH_HANDSHAKEERROR_NO_SHARED_CIPHER = 9,\nSANDWICH_HANDSHAKEERROR_NO_SUITABLE_KEY_SHARE = 10,\n};\ntypedef enum SandwichHandshakeError SandwichHandshakeError;\nenum SandwichTunnelError { SANDWICH_TUNNELERROR_INVALID = 0,\nSANDWICH_TUNNELERROR_VERIFIER = 1,\nSANDWICH_TUNNELERROR_UNKNOWN = 2,\n};\ntypedef enum SandwichTunnelError SandwichTunnelError;\nenum SandwichErrorKind { SANDWICH_ERRORKIND_API = 0,\nSANDWICH_ERRORKIND_CONFIGURATION = 1,\nSANDWICH_ERRORKIND_TLS_CONFIGURATION = 2,\nSANDWICH_ERRORKIND_CERTIFICATE = 3,\nSANDWICH_ERRORKIND_SYSTEM = 4,\nSANDWICH_ERRORKIND_SOCKET = 5,\nSANDWICH_ERRORKIND_PROTOBUF = 6,\nSANDWICH_ERRORKIND_PRIVATE_KEY = 7,\nSANDWICH_ERRORKIND_ASN1 = 8,\nSANDWICH_ERRORKIND_DATA_SOURCE = 9,\nSANDWICH_ERRORKIND_KEM = 10,\nSANDWICH_ERRORKIND_HANDSHAKE = 11,\nSANDWICH_ERRORKIND_TUNNEL = 12,\nSANDWICH_ERRORKIND_ALPN = 13,\nSANDWICH_ERRORKIND_IO = 14,\n};\ntypedef enum SandwichErrorKind SandwichErrorKind;\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n</code></pre>"},{"location":"cAPI/export_8h.html","title":"File export.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; export.h</p> <p>Go to the source code of this file</p>"},{"location":"cAPI/export_8h.html#macros","title":"Macros","text":"Type Name define SANDWICH_API"},{"location":"cAPI/export_8h.html#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"cAPI/export_8h.html#define-sandwich_api","title":"define SANDWICH_API","text":"<pre><code>#define SANDWICH_API \n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/export.h</code></p>"},{"location":"cAPI/export_8h_source.html","title":"File export.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; export.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) SandboxAQ. All rights reserved.\n// SPDX-License-Identifier: AGPL-3.0-only\n#pragma once\n#if (defined(__clang__) || (_GNUC__ &gt;= 4))\n#define SANDWICH_API __attribute__((visibility(\"default\")))\n#else\n#define SANDWICH_API\n#endif\n</code></pre>"},{"location":"cAPI/io_8h.html","title":"File io.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; io.h</p> <p>Go to the source code of this file</p> <p>I/O abstraction for Sandwich. </p> <ul> <li><code>#include &lt;sys/types.h&gt;</code></li> <li><code>#include \"sandwich_c/export.h\"</code></li> <li><code>#include \"sandwich_c/ioerrors.h\"</code></li> </ul>"},{"location":"cAPI/io_8h.html#classes","title":"Classes","text":"Type Name struct SandwichIO A generic I/O interface. struct SandwichIOOwned An IO owned by the Sandwich Library."},{"location":"cAPI/io_8h.html#public-types","title":"Public Types","text":"Type Name typedef SandwichIOFlushFunction * SandwichIOFlushFunctionPtr typedef size_t() SandwichIOReadFunction Read function for the I/O interface. typedef SandwichIOReadFunction * SandwichIOReadFunctionPtr typedef size_t() SandwichIOWriteFunction Write function for the I/O interface. typedef SandwichIOWriteFunction * SandwichIOWriteFunctionPtr typedef void() SandwichOwnedIOFreeFunction A destructor function for owned I/O interface. typedef SandwichOwnedIOFreeFunction * SandwichOwnedIOFreeFunctionPtr"},{"location":"cAPI/io_8h.html#public-functions","title":"Public Functions","text":"Type Name enum SandwichIOError() SandwichIOFlushFunction (void * uarg) Flush function for the I/O interface. SANDWICH_API enum SandwichIOError sandwich_io_client_tcp_new (const char * hostname, uint16_t port, bool async, struct SandwichIOOwned ** ownedIO) Creates a TCP based IO object to be used as an IO. SANDWICH_API void sandwich_io_owned_free (struct SandwichIOOwned * ownedIO) Frees a SandwichIOOwned object created by one of the sandwich_io_*_new() functions. SANDWICH_API enum SandwichIOError sandwich_io_socket_wrap_new (int fd, struct SandwichIOOwned ** ownedIO) Creates an IO object that wraps a UNIX socket."},{"location":"cAPI/io_8h.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"cAPI/io_8h.html#typedef-sandwichioflushfunctionptr","title":"typedef SandwichIOFlushFunctionPtr","text":"<pre><code>typedef SandwichIOFlushFunction* SandwichIOFlushFunctionPtr;\n</code></pre>"},{"location":"cAPI/io_8h.html#typedef-sandwichioreadfunction","title":"typedef SandwichIOReadFunction","text":"<p>Read function for the I/O interface. <pre><code>typedef size_t() SandwichIOReadFunction(void *uarg, void *buf, size_t count, enum SandwichIOError *err);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>uarg</code> User opaque argument. </li> <li><code>buf</code> Destination buffer. </li> <li><code>count</code> Amount of bytes to read. </li> <li><code>err</code> Error, if any.</li> </ul> <p>Returns:</p> <p>The amount of bytes successfully read, or 0. </p>"},{"location":"cAPI/io_8h.html#typedef-sandwichioreadfunctionptr","title":"typedef SandwichIOReadFunctionPtr","text":"<pre><code>typedef SandwichIOReadFunction* SandwichIOReadFunctionPtr;\n</code></pre>"},{"location":"cAPI/io_8h.html#typedef-sandwichiowritefunction","title":"typedef SandwichIOWriteFunction","text":"<p>Write function for the I/O interface. <pre><code>typedef size_t() SandwichIOWriteFunction(void *uarg, const void *buf, size_t count, enum SandwichIOError *err);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>uarg</code> User opaque argument. </li> <li><code>buf</code> Source buffer. </li> <li><code>count</code> Amount of bytes to write. </li> <li><code>err</code> Error, if any.</li> </ul> <p>Returns:</p> <p>The amount of bytes successfully written, or 0. </p>"},{"location":"cAPI/io_8h.html#typedef-sandwichiowritefunctionptr","title":"typedef SandwichIOWriteFunctionPtr","text":"<pre><code>typedef SandwichIOWriteFunction* SandwichIOWriteFunctionPtr;\n</code></pre>"},{"location":"cAPI/io_8h.html#typedef-sandwichownediofreefunction","title":"typedef SandwichOwnedIOFreeFunction","text":"<pre><code>typedef void() SandwichOwnedIOFreeFunction(struct SandwichIO *io);\n</code></pre>"},{"location":"cAPI/io_8h.html#typedef-sandwichownediofreefunctionptr","title":"typedef SandwichOwnedIOFreeFunctionPtr","text":"<pre><code>typedef SandwichOwnedIOFreeFunction* SandwichOwnedIOFreeFunctionPtr;\n</code></pre>"},{"location":"cAPI/io_8h.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"cAPI/io_8h.html#function-sandwichioflushfunction","title":"function SandwichIOFlushFunction","text":"<p>Flush function for the I/O interface. <pre><code>enum SandwichIOError () SandwichIOFlushFunction (\nvoid * uarg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>uarg</code> User opaque argument.</li> </ul> <p>Returns:</p> <p>IOERROR_OK if success, else an IO error. </p>"},{"location":"cAPI/io_8h.html#function-sandwich_io_client_tcp_new","title":"function sandwich_io_client_tcp_new","text":"<p>Creates a TCP based IO object to be used as an IO. <pre><code>SANDWICH_API enum SandwichIOError sandwich_io_client_tcp_new (\nconst char * hostname,\nuint16_t port,\nbool async,\nstruct SandwichIOOwned ** ownedIO\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>hostname</code> the hostname of the target server. </li> <li><code>port</code> the port number of the target server. </li> <li><code>async</code> indicates whether sockets should be non-blocking or not. </li> <li><code>ownedIO</code> the created TCP based sandwich owned IO object.</li> </ul> <p>Returns:</p> <p>IOERROR_OK if the operation was a success, otherwise returns the error that occurred. </p>"},{"location":"cAPI/io_8h.html#function-sandwich_io_owned_free","title":"function sandwich_io_owned_free","text":"<pre><code>SANDWICH_API void sandwich_io_owned_free (\nstruct SandwichIOOwned * ownedIO\n) </code></pre>"},{"location":"cAPI/io_8h.html#function-sandwich_io_socket_wrap_new","title":"function sandwich_io_socket_wrap_new","text":"<p>Creates an IO object that wraps a UNIX socket. <pre><code>SANDWICH_API enum SandwichIOError sandwich_io_socket_wrap_new (\nint fd,\nstruct SandwichIOOwned ** ownedIO\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>fd</code> the file descriptor of the unix socket. </li> <li><code>ownedIO</code> the created UNIX socket sandwich owned IO object. The caller is responsible for freeing that object with sandwich_io_owned_free.</li> </ul> <p>Returns:</p> <p>IOERROR_OK if the operation was a success, otherwise returns the error that occurred. </p> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/io.h</code></p>"},{"location":"cAPI/io_8h_source.html","title":"File io.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; io.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) SandboxAQ. All rights reserved.\n// SPDX-License-Identifier: AGPL-3.0-only\n#pragma once\n#include &lt;sys/types.h&gt;\n#include \"sandwich_c/export.h\"\n#include \"sandwich_c/ioerrors.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\ntypedef size_t(SandwichIOReadFunction)(void *uarg, void *buf, size_t count,\nenum SandwichIOError *err);\ntypedef SandwichIOReadFunction *SandwichIOReadFunctionPtr;\ntypedef size_t(SandwichIOWriteFunction)(void *uarg, const void *buf,\nsize_t count,\nenum SandwichIOError *err);\ntypedef SandwichIOWriteFunction *SandwichIOWriteFunctionPtr;\ntypedef enum SandwichIOError(SandwichIOFlushFunction)(void *uarg);\ntypedef SandwichIOFlushFunction *SandwichIOFlushFunctionPtr;\nstruct SandwichIO {\nSandwichIOReadFunctionPtr read;\nSandwichIOWriteFunctionPtr write;\nSandwichIOFlushFunctionPtr flush;\nvoid *uarg;\n};\ntypedef void(SandwichOwnedIOFreeFunction)(struct SandwichIO *io);\ntypedef SandwichOwnedIOFreeFunction *SandwichOwnedIOFreeFunctionPtr;\nstruct SandwichIOOwned {\nstruct SandwichIO *io;\nSandwichOwnedIOFreeFunctionPtr freeptr;\n};\nSANDWICH_API enum SandwichIOError\nsandwich_io_client_tcp_new(const char *hostname, uint16_t port, bool async,\nstruct SandwichIOOwned **ownedIO);\nSANDWICH_API enum SandwichIOError\nsandwich_io_socket_wrap_new(int fd, struct SandwichIOOwned **ownedIO);\nSANDWICH_API void sandwich_io_owned_free(struct SandwichIOOwned *ownedIO);\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n</code></pre>"},{"location":"cAPI/ioerrors_8h.html","title":"File ioerrors.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; ioerrors.h</p> <p>Go to the source code of this file</p> <p>Sandwich I/O errors specification. </p>"},{"location":"cAPI/ioerrors_8h.html#public-types","title":"Public Types","text":"Type Name enum SandwichIOError Enum IOError. typedef enum SandwichIOError SandwichIOError"},{"location":"cAPI/ioerrors_8h.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"cAPI/ioerrors_8h.html#enum-sandwichioerror","title":"enum SandwichIOError","text":"<pre><code>enum SandwichIOError {\nSANDWICH_IOERROR_OK = 0,\nSANDWICH_IOERROR_IN_PROGRESS = 1,\nSANDWICH_IOERROR_WOULD_BLOCK = 2,\nSANDWICH_IOERROR_REFUSED = 3,\nSANDWICH_IOERROR_CLOSED = 4,\nSANDWICH_IOERROR_INVALID = 5,\nSANDWICH_IOERROR_UNKNOWN = 6,\nSANDWICH_IOERROR_SYSTEM_ERROR = 7,\nSANDWICH_IOERROR_ADDRESS_IN_USE = 8\n};\n</code></pre>"},{"location":"cAPI/ioerrors_8h.html#typedef-sandwichioerror","title":"typedef SandwichIOError","text":"<pre><code>typedef enum SandwichIOError SandwichIOError;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/ioerrors.h</code></p>"},{"location":"cAPI/ioerrors_8h_source.html","title":"File ioerrors.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; ioerrors.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 SandboxAQ\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#pragma once\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nenum SandwichIOError { SANDWICH_IOERROR_OK = 0,\nSANDWICH_IOERROR_IN_PROGRESS = 1,\nSANDWICH_IOERROR_WOULD_BLOCK = 2,\nSANDWICH_IOERROR_REFUSED = 3,\nSANDWICH_IOERROR_CLOSED = 4,\nSANDWICH_IOERROR_INVALID = 5,\nSANDWICH_IOERROR_UNKNOWN = 6,\nSANDWICH_IOERROR_SYSTEM_ERROR = 7,\nSANDWICH_IOERROR_ADDRESS_IN_USE = 8,\n};\ntypedef enum SandwichIOError SandwichIOError;\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n</code></pre>"},{"location":"cAPI/lib_8h.html","title":"File lib.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; lib.h</p> <p>Go to the source code of this file</p> <p>Top-level context for the Sandwich library. </p> <ul> <li><code>#include \"sandwich_c/export.h\"</code></li> </ul>"},{"location":"cAPI/lib_8h.html#public-functions","title":"Public Functions","text":"Type Name SANDWICH_API void sandwich_lib_context_free (struct SandwichContext * sw) Free a top-level Sandwich context. SANDWICH_API struct SandwichContext * sandwich_lib_context_new (void) Create a top-level Sandwich context."},{"location":"cAPI/lib_8h.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"cAPI/lib_8h.html#function-sandwich_lib_context_free","title":"function sandwich_lib_context_free","text":"<p>Free a top-level Sandwich context. <pre><code>SANDWICH_API void sandwich_lib_context_free (\nstruct SandwichContext * sw\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sw</code> Top-level Sandwich context to free.</li> </ul> <p>NULL for <code>sw</code> is allowed. </p>"},{"location":"cAPI/lib_8h.html#function-sandwich_lib_context_new","title":"function sandwich_lib_context_new","text":"<p>Create a top-level Sandwich context. <pre><code>SANDWICH_API struct SandwichContext * sandwich_lib_context_new (\nvoid\n) </code></pre></p> <p>Returns:</p> <p>A new top-level Sandwich context. </p> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/lib.h</code></p>"},{"location":"cAPI/lib_8h_source.html","title":"File lib.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; lib.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) SandboxAQ. All rights reserved.\n// SPDX-License-Identifier: AGPL-3.0-only\n#pragma once\n#include \"sandwich_c/export.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nstruct SandwichContext;\nSANDWICH_API struct SandwichContext *sandwich_lib_context_new(void);\nSANDWICH_API void sandwich_lib_context_free(struct SandwichContext *sw);\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n</code></pre>"},{"location":"cAPI/listener_8h.html","title":"File listener.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; listener.h</p> <p>Go to the source code of this file</p> <p>Sandwich C library, on top of the Rust implementation. </p> <ul> <li><code>#include &lt;sys/types.h&gt;</code></li> <li><code>#include \"sandwich_c/export.h\"</code></li> <li><code>#include \"sandwich_c/io.h\"</code></li> </ul>"},{"location":"cAPI/listener_8h.html#public-functions","title":"Public Functions","text":"Type Name SANDWICH_API enum SandwichIOError sandwich_listener_accept (struct SandwichListener * listener, struct SandwichIOOwned ** ownedIO) Prompts the Listener to start accepting connections. SANDWICH_API void sandwich_listener_close (struct SandwichListener * listener) Closes the listener to new connections. SANDWICH_API void sandwich_listener_free (struct SandwichListener * listener) Frees the given listener. SANDWICH_API enum SandwichIOError sandwich_listener_listen (struct SandwichListener * listener) Causes the Listener to start listening for connections. SANDWICH_API struct SandwichError * sandwich_listener_new (const void * src, size_t n, struct SandwichListener ** out) Creates a a new Listener object."},{"location":"cAPI/listener_8h.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"cAPI/listener_8h.html#function-sandwich_listener_accept","title":"function sandwich_listener_accept","text":"<p>Prompts the Listener to start accepting connections. <pre><code>SANDWICH_API enum SandwichIOError sandwich_listener_accept (\nstruct SandwichListener * listener,\nstruct SandwichIOOwned ** ownedIO\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>listener</code> the listener which should start accepting connections. </li> <li><code>ownedIO</code> the newly created OwnedIO struct containing the IO object to use with a tunnel. Null if an error occurs.</li> </ul> <p>Returns:</p> <p>IOERROR_OK if the operation was a success, otherwise returns the error that occurred. </p>"},{"location":"cAPI/listener_8h.html#function-sandwich_listener_close","title":"function sandwich_listener_close","text":"<p>Closes the listener to new connections. <pre><code>SANDWICH_API void sandwich_listener_close (\nstruct SandwichListener * listener\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>listener</code> the listener which should close. </li> </ul>"},{"location":"cAPI/listener_8h.html#function-sandwich_listener_free","title":"function sandwich_listener_free","text":"<p>Frees the given listener. <pre><code>SANDWICH_API void sandwich_listener_free (\nstruct SandwichListener * listener\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>listener</code> the listener which should start accepting connections. </li> </ul>"},{"location":"cAPI/listener_8h.html#function-sandwich_listener_listen","title":"function sandwich_listener_listen","text":"<p>Causes the Listener to start listening for connections. <pre><code>SANDWICH_API enum SandwichIOError sandwich_listener_listen (\nstruct SandwichListener * listener\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>listener</code> The listener object that should start listening for new connections.</li> </ul> <p>Returns:</p> <p>IOERROR_OK if the operation was a success, otherwise returns the error that occurred. </p>"},{"location":"cAPI/listener_8h.html#function-sandwich_listener_new","title":"function sandwich_listener_new","text":"<p>Creates a a new Listener object. <pre><code>SANDWICH_API struct SandwichError * sandwich_listener_new (\nconst void * src,\nsize_t n,\nstruct SandwichListener ** out\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>src</code> a serialized <code>ListenerConfiguration</code> protobuf message. </li> <li><code>n</code> the length of src. </li> <li><code>out</code> points to the newly created listener.</li> </ul> <p>Returns:</p> <p>Error, if any. </p> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/listener.h</code></p>"},{"location":"cAPI/listener_8h_source.html","title":"File listener.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; listener.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) SandboxAQ. All rights reserved.\n// SPDX-License-Identifier: AGPL-3.0-only\n#pragma once\n#include &lt;sys/types.h&gt;\n#include \"sandwich_c/export.h\"\n#include \"sandwich_c/io.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nstruct SandwichListener;\nSANDWICH_API struct SandwichError *\nsandwich_listener_new(const void *src, size_t n, struct SandwichListener **out);\nSANDWICH_API enum SandwichIOError\nsandwich_listener_listen(struct SandwichListener *listener);\nSANDWICH_API enum SandwichIOError\nsandwich_listener_accept(struct SandwichListener *listener,\nstruct SandwichIOOwned **ownedIO);\nSANDWICH_API void sandwich_listener_close(struct SandwichListener *listener);\nSANDWICH_API void sandwich_listener_free(struct SandwichListener *listener);\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n</code></pre>"},{"location":"cAPI/sandwich_8h.html","title":"File sandwich.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; sandwich.h</p> <p>Go to the source code of this file</p> <p>Sandwich C library, on top of the Rust implementation. </p> <ul> <li><code>#include \"sandwich_c/error.h\"</code></li> <li><code>#include \"sandwich_c/io.h\"</code></li> <li><code>#include \"sandwich_c/lib.h\"</code></li> <li><code>#include \"sandwich_c/listener.h\"</code></li> <li><code>#include \"sandwich_c/tunnel.h\"</code></li> <li><code>#include \"sandwich_c/tracer.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/sandwich.h</code></p>"},{"location":"cAPI/sandwich_8h_source.html","title":"File sandwich.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; sandwich.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) SandboxAQ. All rights reserved.\n// SPDX-License-Identifier: AGPL-3.0-only\n#pragma once\n#include \"sandwich_c/error.h\"\n#include \"sandwich_c/io.h\"\n#include \"sandwich_c/lib.h\"\n#include \"sandwich_c/listener.h\"\n#include \"sandwich_c/tunnel.h\"\n#include \"sandwich_c/tracer.h\"\n</code></pre>"},{"location":"cAPI/tracer_8h.html","title":"File tracer.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; tracer.h</p> <p>Go to the source code of this file</p> <p>Sandwich Tracer API. </p> <ul> <li><code>#include &lt;sys/types.h&gt;</code></li> <li><code>#include \"sandwich_c/export.h\"</code></li> <li><code>#include \"sandwich_c/tunnel.h\"</code></li> </ul>"},{"location":"cAPI/tracer_8h.html#public-functions","title":"Public Functions","text":"Type Name SANDWICH_API void sandwich_tunnel_add_tracer (struct SandwichTunnel * tun, const char * context_cstr, int fd) Adds a tracer object to a tunnel, allows for context propagation."},{"location":"cAPI/tracer_8h.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"cAPI/tracer_8h.html#function-sandwich_tunnel_add_tracer","title":"function sandwich_tunnel_add_tracer","text":"<p>Adds a tracer object to a tunnel, allows for context propagation. <pre><code>SANDWICH_API void sandwich_tunnel_add_tracer (\nstruct SandwichTunnel * tun,\nconst char * context_cstr,\nint fd\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>tun</code> Tunnel to associate tracer with. </li> <li><code>context_cstr</code> A string representing the context from OpenTelemetry. </li> <li><code>fd</code> File Descriptor where the tracer will write to. </li> </ul> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/tracer.h</code></p>"},{"location":"cAPI/tracer_8h_source.html","title":"File tracer.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; tracer.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) SandboxAQ. All rights reserved.\n// SPDX-License-Identifier: AGPL-3.0-only\n#pragma once\n#include &lt;sys/types.h&gt;\n#include \"sandwich_c/export.h\"\n#include \"sandwich_c/tunnel.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nSANDWICH_API void sandwich_tunnel_add_tracer(struct SandwichTunnel *tun, const char *context_cstr, int fd);\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n</code></pre>"},{"location":"cAPI/tunnel_8h.html","title":"File tunnel.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; tunnel.h</p> <p>Go to the source code of this file</p> <p>Sandwich Tunnel API. </p> <ul> <li><code>#include &lt;sys/types.h&gt;</code></li> <li><code>#include \"sandwich_c/export.h\"</code></li> <li><code>#include \"sandwich_c/io.h\"</code></li> <li><code>#include \"sandwich_c/tunnel_types.h\"</code></li> </ul>"},{"location":"cAPI/tunnel_8h.html#classes","title":"Classes","text":"Type Name struct SandwichTunnelConfigurationSerialized A serialized <code>TunnelConfiguration</code> message. struct SandwichTunnelContextConfigurationSerialized A serialized <code>Configuration</code> message. struct SandwichTunnelIO An IO specific to tunnels."},{"location":"cAPI/tunnel_8h.html#public-types","title":"Public Types","text":"Type Name typedef void() SandwichTunnelIOSetStateFunction An IO callback triggered when the state of the tunnel changes. typedef SandwichTunnelIOSetStateFunction * SandwichTunnelIOSetStateFunctionPtr"},{"location":"cAPI/tunnel_8h.html#public-attributes","title":"Public Attributes","text":"Type Name struct SandwichTunnelConfigurationSerialized SandwichTunnelConfigurationVerifierEmpty A tunnel configuration containing an empty Tunnel Verifier."},{"location":"cAPI/tunnel_8h.html#public-functions","title":"Public Functions","text":"Type Name SANDWICH_API struct SandwichTunnelIO sandwich_owned_io_to_tunnel_io (const struct SandwichIOOwned * owned_io) Return the view of a tunnel IO from an owned IO. SANDWICH_API void sandwich_tunnel_close (struct SandwichTunnel * tun) Close the tunnel. SANDWICH_API void sandwich_tunnel_context_free (struct SandwichTunnelContext * ctx) Free a Sandwich tunnel context. SANDWICH_API struct SandwichError * sandwich_tunnel_context_new (const struct SandwichContext * sw, struct SandwichTunnelContextConfigurationSerialized configuration, struct SandwichTunnelContext ** ctx) Create a context from an encoded protobuf message. SANDWICH_API void sandwich_tunnel_free (struct SandwichTunnel * tun) Free a Sandwich tunnel. SANDWICH_API struct SandwichError * sandwich_tunnel_handshake (struct SandwichTunnel * tun, enum SandwichTunnelHandshakeState * state) Perform the handshake. SANDWICH_API struct SandwichError * sandwich_tunnel_new (struct SandwichTunnelContext * ctx, const struct SandwichTunnelIO * io, struct SandwichTunnelConfigurationSerialized configuration, struct SandwichTunnel ** tun) Create a tunnel. SANDWICH_API enum SandwichTunnelRecordError sandwich_tunnel_read (struct SandwichTunnel * tun, void * dst, size_t n, size_t * r) Read some bytes from the record plane of the tunnel. SANDWICH_API enum SandwichTunnelState sandwich_tunnel_state (const struct SandwichTunnel * tun) Get the state of the tunnel. SANDWICH_API enum SandwichTunnelRecordError sandwich_tunnel_write (struct SandwichTunnel * tun, const void * src, size_t n, size_t * w) Write some bytes to the record plane of the tunnel."},{"location":"cAPI/tunnel_8h.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"cAPI/tunnel_8h.html#typedef-sandwichtunneliosetstatefunction","title":"typedef SandwichTunnelIOSetStateFunction","text":"<p>An IO callback triggered when the state of the tunnel changes. <pre><code>typedef void() SandwichTunnelIOSetStateFunction(void *uarg, enum SandwichTunnelState tunnel_state);\n</code></pre></p> <p>It is guaranteed that the state of the tunnel will not change between two calls to this callback.</p> <p>Parameters:</p> <ul> <li><code>uarg</code> User opaque argument. </li> <li><code>tunnel_state</code> The new state of the tunnel. </li> </ul>"},{"location":"cAPI/tunnel_8h.html#typedef-sandwichtunneliosetstatefunctionptr","title":"typedef SandwichTunnelIOSetStateFunctionPtr","text":"<pre><code>typedef SandwichTunnelIOSetStateFunction* SandwichTunnelIOSetStateFunctionPtr;\n</code></pre>"},{"location":"cAPI/tunnel_8h.html#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"cAPI/tunnel_8h.html#variable-sandwichtunnelconfigurationverifierempty","title":"variable SandwichTunnelConfigurationVerifierEmpty","text":"<pre><code>struct SandwichTunnelConfigurationSerialized SandwichTunnelConfigurationVerifierEmpty;\n</code></pre>"},{"location":"cAPI/tunnel_8h.html#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"cAPI/tunnel_8h.html#function-sandwich_owned_io_to_tunnel_io","title":"function sandwich_owned_io_to_tunnel_io","text":"<p>Return the view of a tunnel IO from an owned IO. <pre><code>SANDWICH_API struct SandwichTunnelIO sandwich_owned_io_to_tunnel_io (\nconst struct SandwichIOOwned * owned_io\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>owned_io</code> Owned io.</li> </ul> <p>The tunnel IO returned by this function is a view of the owned IO. It means that the user is STILL responsible for freeing the owned IO using <code>sandwich_io_owned_free</code>. Once freed, the view can no longer be used.</p> <p>Returns:</p> <p>A view of the owned IO as a tunnel IO. </p>"},{"location":"cAPI/tunnel_8h.html#function-sandwich_tunnel_close","title":"function sandwich_tunnel_close","text":"<p>Close the tunnel. <pre><code>SANDWICH_API void sandwich_tunnel_close (\nstruct SandwichTunnel * tun\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>tun</code> Tunnel to close. </li> </ul>"},{"location":"cAPI/tunnel_8h.html#function-sandwich_tunnel_context_free","title":"function sandwich_tunnel_context_free","text":"<p>Free a Sandwich tunnel context. <pre><code>SANDWICH_API void sandwich_tunnel_context_free (\nstruct SandwichTunnelContext * ctx\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> Context to free.</li> </ul> <p>NULL for <code>ctx</code> is allowed. </p>"},{"location":"cAPI/tunnel_8h.html#function-sandwich_tunnel_context_new","title":"function sandwich_tunnel_context_new","text":"<p>Create a context from an encoded protobuf message. <pre><code>SANDWICH_API struct SandwichError * sandwich_tunnel_context_new (\nconst struct SandwichContext * sw,\nstruct SandwichTunnelContextConfigurationSerialized configuration,\nstruct SandwichTunnelContext ** ctx\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sw</code> Top-level Sandwich context. </li> <li><code>configuration</code> Serialized configuration. </li> <li><code>ctx</code> The new Sandwich context object.</li> </ul> <p>Returns:</p> <p>NULL if no error occured, else a chain of errors. </p>"},{"location":"cAPI/tunnel_8h.html#function-sandwich_tunnel_free","title":"function sandwich_tunnel_free","text":"<p>Free a Sandwich tunnel. <pre><code>SANDWICH_API void sandwich_tunnel_free (\nstruct SandwichTunnel * tun\n) </code></pre></p> <p>If the I/O interface is still owned by the tunnel, it will be freed too.</p> <p>Parameters:</p> <ul> <li><code>tun</code> Tunnel to free.</li> </ul> <p>NULL for <code>tun</code> is allowed. </p>"},{"location":"cAPI/tunnel_8h.html#function-sandwich_tunnel_handshake","title":"function sandwich_tunnel_handshake","text":"<p>Perform the handshake. <pre><code>SANDWICH_API struct SandwichError * sandwich_tunnel_handshake (\nstruct SandwichTunnel * tun,\nenum SandwichTunnelHandshakeState * state\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>tun</code> Tunnel. </li> <li><code>state</code> The state of the tunnel</li> </ul> <p>Returns:</p> <p>Null if no error occured, else a chain of errors. </p>"},{"location":"cAPI/tunnel_8h.html#function-sandwich_tunnel_new","title":"function sandwich_tunnel_new","text":"<p>Create a tunnel. <pre><code>SANDWICH_API struct SandwichError * sandwich_tunnel_new (\nstruct SandwichTunnelContext * ctx,\nconst struct SandwichTunnelIO * io,\nstruct SandwichTunnelConfigurationSerialized configuration,\nstruct SandwichTunnel ** tun\n) </code></pre></p> <p>A tunnel is created from an IO interface. <code>SandwichTunnelIO</code> are used to create an IO interface that forwards calls to the <code>read</code>, and <code>write</code> of <code>SandwichTunnelIO</code>. The state of the tunnel is exposed to the IO interface through the SandwichTunnelIO-&gt;set_state function.</p> <p>Since the implementation of <code>sandwich_tunnel_new</code> makes a copy of <code>SandwichTunnelIO</code>, the caller does not need to keep <code>io</code> in memory. In other words, Sandwich does not take the ownership of <code>io</code>.</p> <p>Parameters:</p> <ul> <li><code>ctx</code> Sandwich context used for setting up the tunnel. </li> <li><code>io</code> I/O interface to use to create the I/O interface. </li> <li><code>configuration</code> Additional configuration the connection is subject to. A null pointer is undefined behavior. </li> <li><code>tun</code> The new Sandwich tunnel object.</li> </ul> <p>Returns:</p> <p>NULL if no error occured, else a chain of errors. </p>"},{"location":"cAPI/tunnel_8h.html#function-sandwich_tunnel_read","title":"function sandwich_tunnel_read","text":"<p>Read some bytes from the record plane of the tunnel. <pre><code>SANDWICH_API enum SandwichTunnelRecordError sandwich_tunnel_read (\nstruct SandwichTunnel * tun,\nvoid * dst,\nsize_t n,\nsize_t * r\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>tun</code> Tunnel.. </li> <li><code>dst</code> Destination buffer. </li> <li><code>n</code> Amount of bytes to read. </li> <li><code>r</code> Amount of bytes successfully read.</li> </ul> <p>NULL for <code>r</code> is allowed.</p> <p>Returns:</p> <p>An error code. </p>"},{"location":"cAPI/tunnel_8h.html#function-sandwich_tunnel_state","title":"function sandwich_tunnel_state","text":"<p>Get the state of the tunnel. <pre><code>SANDWICH_API enum SandwichTunnelState sandwich_tunnel_state (\nconst struct SandwichTunnel * tun\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>tun</code> Tunnel.</li> </ul> <p>Returns:</p> <p>The state of the tunnel. </p>"},{"location":"cAPI/tunnel_8h.html#function-sandwich_tunnel_write","title":"function sandwich_tunnel_write","text":"<p>Write some bytes to the record plane of the tunnel. <pre><code>SANDWICH_API enum SandwichTunnelRecordError sandwich_tunnel_write (\nstruct SandwichTunnel * tun,\nconst void * src,\nsize_t n,\nsize_t * w\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>tun</code> Tunnel. </li> <li><code>src</code> Source buffer. </li> <li><code>n</code> Amount of bytes to read. </li> <li><code>w</code> Amount of bytes successfully written.</li> </ul> <p>NULL for <code>w</code> is allowed.</p> <p>Returns:</p> <p>An error code. </p> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/tunnel.h</code></p>"},{"location":"cAPI/tunnel_8h_source.html","title":"File tunnel.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; tunnel.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright (c) SandboxAQ. All rights reserved.\n// SPDX-License-Identifier: AGPL-3.0-only\n#pragma once\n#include &lt;sys/types.h&gt;\n#include \"sandwich_c/export.h\"\n#include \"sandwich_c/io.h\"\n#include \"sandwich_c/tunnel_types.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nstruct SandwichTunnelContext;\nstruct SandwichTunnelContextConfigurationSerialized {\nconst void *src;\nsize_t n;\n};\nstruct SandwichTunnelConfigurationSerialized {\nconst void *src;\nsize_t n;\n};\nextern struct SandwichTunnelConfigurationSerialized\nSandwichTunnelConfigurationVerifierEmpty;\nstruct SandwichTunnel;\ntypedef void(SandwichTunnelIOSetStateFunction)(\nvoid *uarg, enum SandwichTunnelState tunnel_state);\ntypedef SandwichTunnelIOSetStateFunction *SandwichTunnelIOSetStateFunctionPtr;\nstruct SandwichTunnelIO {\nstruct SandwichIO base;\nSandwichTunnelIOSetStateFunctionPtr set_state;\n};\nSANDWICH_API struct SandwichError *sandwich_tunnel_context_new(\nconst struct SandwichContext *sw,\nstruct SandwichTunnelContextConfigurationSerialized configuration,\nstruct SandwichTunnelContext **ctx);\nSANDWICH_API void\nsandwich_tunnel_context_free(struct SandwichTunnelContext *ctx);\nSANDWICH_API struct SandwichError *\nsandwich_tunnel_new(struct SandwichTunnelContext *ctx,\nconst struct SandwichTunnelIO *io,\nstruct SandwichTunnelConfigurationSerialized configuration,\nstruct SandwichTunnel **tun);\nSANDWICH_API struct SandwichError *\nsandwich_tunnel_handshake(struct SandwichTunnel *tun,\nenum SandwichTunnelHandshakeState *state);\nSANDWICH_API enum SandwichTunnelRecordError\nsandwich_tunnel_read(struct SandwichTunnel *tun, void *dst, size_t n,\nsize_t *r);\nSANDWICH_API enum SandwichTunnelRecordError\nsandwich_tunnel_write(struct SandwichTunnel *tun, const void *src, size_t n,\nsize_t *w);\nSANDWICH_API void sandwich_tunnel_close(struct SandwichTunnel *tun);\nSANDWICH_API enum SandwichTunnelState\nsandwich_tunnel_state(const struct SandwichTunnel *tun);\nSANDWICH_API void sandwich_tunnel_free(struct SandwichTunnel *tun);\nSANDWICH_API struct SandwichTunnelIO\nsandwich_owned_io_to_tunnel_io(const struct SandwichIOOwned *owned_io);\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n</code></pre>"},{"location":"cAPI/tunnel__types_8h.html","title":"File tunnel_types.h","text":"<p>FileList &gt; docs &gt; sandwich_c &gt; tunnel_types.h</p> <p>Go to the source code of this file</p> <p>Sandwich tunnel types and states specification. </p>"},{"location":"cAPI/tunnel__types_8h.html#public-types","title":"Public Types","text":"Type Name enum SandwichTunnelHandshakeState Enum HandshakeState. typedef enum SandwichTunnelHandshakeState SandwichTunnelHandshakeState enum SandwichTunnelRecordError Enum RecordError. typedef enum SandwichTunnelRecordError SandwichTunnelRecordError enum SandwichTunnelState Enum State. typedef enum SandwichTunnelState SandwichTunnelState"},{"location":"cAPI/tunnel__types_8h.html#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"cAPI/tunnel__types_8h.html#enum-sandwichtunnelhandshakestate","title":"enum SandwichTunnelHandshakeState","text":"<pre><code>enum SandwichTunnelHandshakeState {\nSANDWICH_TUNNEL_HANDSHAKESTATE_IN_PROGRESS = 0,\nSANDWICH_TUNNEL_HANDSHAKESTATE_DONE = 1,\nSANDWICH_TUNNEL_HANDSHAKESTATE_WANT_READ = 2,\nSANDWICH_TUNNEL_HANDSHAKESTATE_WANT_WRITE = 3,\nSANDWICH_TUNNEL_HANDSHAKESTATE_ERROR = 4\n};\n</code></pre>"},{"location":"cAPI/tunnel__types_8h.html#typedef-sandwichtunnelhandshakestate","title":"typedef SandwichTunnelHandshakeState","text":"<pre><code>typedef enum SandwichTunnelHandshakeState SandwichTunnelHandshakeState;\n</code></pre>"},{"location":"cAPI/tunnel__types_8h.html#enum-sandwichtunnelrecorderror","title":"enum SandwichTunnelRecordError","text":"<pre><code>enum SandwichTunnelRecordError {\nSANDWICH_TUNNEL_RECORDERROR_OK = 0,\nSANDWICH_TUNNEL_RECORDERROR_WANT_READ = 1,\nSANDWICH_TUNNEL_RECORDERROR_WANT_WRITE = 2,\nSANDWICH_TUNNEL_RECORDERROR_BEING_SHUTDOWN = 3,\nSANDWICH_TUNNEL_RECORDERROR_CLOSED = 4,\nSANDWICH_TUNNEL_RECORDERROR_TOO_BIG = 5,\nSANDWICH_TUNNEL_RECORDERROR_UNKNOWN = 6\n};\n</code></pre>"},{"location":"cAPI/tunnel__types_8h.html#typedef-sandwichtunnelrecorderror","title":"typedef SandwichTunnelRecordError","text":"<pre><code>typedef enum SandwichTunnelRecordError SandwichTunnelRecordError;\n</code></pre>"},{"location":"cAPI/tunnel__types_8h.html#enum-sandwichtunnelstate","title":"enum SandwichTunnelState","text":"<pre><code>enum SandwichTunnelState {\nSANDWICH_TUNNEL_STATE_NOT_CONNECTED = 0,\nSANDWICH_TUNNEL_STATE_CONNECTION_IN_PROGRESS = 1,\nSANDWICH_TUNNEL_STATE_HANDSHAKE_IN_PROGRESS = 2,\nSANDWICH_TUNNEL_STATE_HANDSHAKE_DONE = 3,\nSANDWICH_TUNNEL_STATE_BEING_SHUTDOWN = 4,\nSANDWICH_TUNNEL_STATE_DISCONNECTED = 5,\nSANDWICH_TUNNEL_STATE_ERROR = 6\n};\n</code></pre>"},{"location":"cAPI/tunnel__types_8h.html#typedef-sandwichtunnelstate","title":"typedef SandwichTunnelState","text":"<pre><code>typedef enum SandwichTunnelState SandwichTunnelState;\n</code></pre> <p>The documentation for this class was generated from the following file <code>docs/sandwich_c/tunnel_types.h</code></p>"},{"location":"cAPI/tunnel__types_8h_source.html","title":"File tunnel_types.h","text":"<p>File List &gt; docs &gt; sandwich_c &gt; tunnel_types.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 SandboxAQ\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#pragma once\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nenum SandwichTunnelState { SANDWICH_TUNNEL_STATE_NOT_CONNECTED = 0,\nSANDWICH_TUNNEL_STATE_CONNECTION_IN_PROGRESS = 1,\nSANDWICH_TUNNEL_STATE_HANDSHAKE_IN_PROGRESS = 2,\nSANDWICH_TUNNEL_STATE_HANDSHAKE_DONE = 3,\nSANDWICH_TUNNEL_STATE_BEING_SHUTDOWN = 4,\nSANDWICH_TUNNEL_STATE_DISCONNECTED = 5,\nSANDWICH_TUNNEL_STATE_ERROR = 6,\n};\ntypedef enum SandwichTunnelState SandwichTunnelState;\nenum SandwichTunnelHandshakeState { SANDWICH_TUNNEL_HANDSHAKESTATE_IN_PROGRESS = 0,\nSANDWICH_TUNNEL_HANDSHAKESTATE_DONE = 1,\nSANDWICH_TUNNEL_HANDSHAKESTATE_WANT_READ = 2,\nSANDWICH_TUNNEL_HANDSHAKESTATE_WANT_WRITE = 3,\nSANDWICH_TUNNEL_HANDSHAKESTATE_ERROR = 4,\n};\ntypedef enum SandwichTunnelHandshakeState SandwichTunnelHandshakeState;\nenum SandwichTunnelRecordError { SANDWICH_TUNNEL_RECORDERROR_OK = 0,\nSANDWICH_TUNNEL_RECORDERROR_WANT_READ = 1,\nSANDWICH_TUNNEL_RECORDERROR_WANT_WRITE = 2,\nSANDWICH_TUNNEL_RECORDERROR_BEING_SHUTDOWN = 3,\nSANDWICH_TUNNEL_RECORDERROR_CLOSED = 4,\nSANDWICH_TUNNEL_RECORDERROR_TOO_BIG = 5,\nSANDWICH_TUNNEL_RECORDERROR_UNKNOWN = 6,\n};\ntypedef enum SandwichTunnelRecordError SandwichTunnelRecordError;\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n</code></pre>"},{"location":"cAPI/namespaces.html","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"cAPI/classes.html","title":"Class Index","text":""},{"location":"cAPI/classes.html#s","title":"s","text":"<ul> <li>SandwichError</li> <li>SandwichIO</li> <li>SandwichIOOwned</li> <li>SandwichTunnelConfigurationSerialized</li> <li>SandwichTunnelContextConfigurationSerialized</li> <li>SandwichTunnelIO</li> </ul>"},{"location":"cAPI/hierarchy.html","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>struct SandwichError An error code. </li> <li>struct SandwichIO A generic I/O interface. </li> <li>struct SandwichIOOwned An IO owned by the Sandwich Library. </li> <li>struct SandwichTunnelConfigurationSerialized A serialized <code>TunnelConfiguration</code> message.</li> <li>struct SandwichTunnelContextConfigurationSerialized A serialized <code>Configuration</code> message.</li> <li>struct SandwichTunnelIO An IO specific to tunnels. </li> </ul>"},{"location":"cAPI/modules.html","title":"Modules","text":"<p>No modules found.</p>"},{"location":"cAPI/pages.html","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"cAPI/class_members.html","title":"Class Members","text":""},{"location":"cAPI/class_members.html#b","title":"b","text":"<ul> <li>base (SandwichTunnelIO)</li> </ul>"},{"location":"cAPI/class_members.html#c","title":"c","text":"<ul> <li>code (SandwichError)</li> </ul>"},{"location":"cAPI/class_members.html#d","title":"d","text":"<ul> <li>details (SandwichError)</li> </ul>"},{"location":"cAPI/class_members.html#f","title":"f","text":"<ul> <li>flush (SandwichIO)</li> <li>freeptr (SandwichIOOwned)</li> </ul>"},{"location":"cAPI/class_members.html#i","title":"i","text":"<ul> <li>io (SandwichIOOwned)</li> </ul>"},{"location":"cAPI/class_members.html#k","title":"k","text":"<ul> <li>kind (SandwichError)</li> </ul>"},{"location":"cAPI/class_members.html#m","title":"m","text":"<ul> <li>msg (SandwichError)</li> </ul>"},{"location":"cAPI/class_members.html#n","title":"n","text":"<ul> <li>n (SandwichTunnelConfigurationSerialized, SandwichTunnelContextConfigurationSerialized)</li> </ul>"},{"location":"cAPI/class_members.html#r","title":"r","text":"<ul> <li>read (SandwichIO)</li> </ul>"},{"location":"cAPI/class_members.html#s","title":"s","text":"<ul> <li>src (SandwichTunnelConfigurationSerialized, SandwichTunnelContextConfigurationSerialized)</li> <li>set_state (SandwichTunnelIO)</li> </ul>"},{"location":"cAPI/class_members.html#u","title":"u","text":"<ul> <li>uarg (SandwichIO)</li> </ul>"},{"location":"cAPI/class_members.html#w","title":"w","text":"<ul> <li>write (SandwichIO)</li> </ul>"},{"location":"cAPI/class_member_functions.html","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"cAPI/class_member_variables.html","title":"Class Member Variables","text":""},{"location":"cAPI/class_member_variables.html#b","title":"b","text":"<ul> <li>base (SandwichTunnelIO)</li> </ul>"},{"location":"cAPI/class_member_variables.html#c","title":"c","text":"<ul> <li>code (SandwichError)</li> </ul>"},{"location":"cAPI/class_member_variables.html#d","title":"d","text":"<ul> <li>details (SandwichError)</li> </ul>"},{"location":"cAPI/class_member_variables.html#f","title":"f","text":"<ul> <li>flush (SandwichIO)</li> <li>freeptr (SandwichIOOwned)</li> </ul>"},{"location":"cAPI/class_member_variables.html#i","title":"i","text":"<ul> <li>io (SandwichIOOwned)</li> </ul>"},{"location":"cAPI/class_member_variables.html#k","title":"k","text":"<ul> <li>kind (SandwichError)</li> </ul>"},{"location":"cAPI/class_member_variables.html#m","title":"m","text":"<ul> <li>msg (SandwichError)</li> </ul>"},{"location":"cAPI/class_member_variables.html#n","title":"n","text":"<ul> <li>n (SandwichTunnelConfigurationSerialized, SandwichTunnelContextConfigurationSerialized)</li> </ul>"},{"location":"cAPI/class_member_variables.html#r","title":"r","text":"<ul> <li>read (SandwichIO)</li> </ul>"},{"location":"cAPI/class_member_variables.html#s","title":"s","text":"<ul> <li>src (SandwichTunnelConfigurationSerialized, SandwichTunnelContextConfigurationSerialized)</li> <li>set_state (SandwichTunnelIO)</li> </ul>"},{"location":"cAPI/class_member_variables.html#u","title":"u","text":"<ul> <li>uarg (SandwichIO)</li> </ul>"},{"location":"cAPI/class_member_variables.html#w","title":"w","text":"<ul> <li>write (SandwichIO)</li> </ul>"},{"location":"cAPI/class_member_typedefs.html","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"cAPI/class_member_enums.html","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"cAPI/namespace_members.html","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"cAPI/namespace_member_functions.html","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"cAPI/namespace_member_variables.html","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"cAPI/namespace_member_typedefs.html","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"cAPI/namespace_member_enums.html","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"cAPI/functions.html","title":"Functions","text":""},{"location":"cAPI/functions.html#s","title":"s","text":"<ul> <li>sandwich_error_free (error.h)</li> <li>sandwich_error_stack_str_free (error.h)</li> <li>sandwich_error_stack_str_new (error.h)</li> <li>SandwichIOFlushFunction (io.h)</li> <li>sandwich_io_client_tcp_new (io.h)</li> <li>sandwich_io_owned_free (io.h)</li> <li>sandwich_io_socket_wrap_new (io.h)</li> <li>sandwich_lib_context_free (lib.h)</li> <li>sandwich_lib_context_new (lib.h)</li> <li>sandwich_listener_accept (listener.h)</li> <li>sandwich_listener_close (listener.h)</li> <li>sandwich_listener_free (listener.h)</li> <li>sandwich_listener_listen (listener.h)</li> <li>sandwich_listener_new (listener.h)</li> <li>sandwich_tunnel_add_tracer (tracer.h)</li> <li>sandwich_owned_io_to_tunnel_io (tunnel.h)</li> <li>sandwich_tunnel_close (tunnel.h)</li> <li>sandwich_tunnel_context_free (tunnel.h)</li> <li>sandwich_tunnel_context_new (tunnel.h)</li> <li>sandwich_tunnel_free (tunnel.h)</li> <li>sandwich_tunnel_handshake (tunnel.h)</li> <li>sandwich_tunnel_new (tunnel.h)</li> <li>sandwich_tunnel_read (tunnel.h)</li> <li>sandwich_tunnel_state (tunnel.h)</li> <li>sandwich_tunnel_write (tunnel.h)</li> </ul>"},{"location":"cAPI/macros.html","title":"Macros","text":""},{"location":"cAPI/macros.html#s","title":"s","text":"<ul> <li>SANDWICH_API (export.h)</li> </ul>"},{"location":"cAPI/variables.html","title":"Variables","text":""},{"location":"cAPI/variables.html#s","title":"s","text":"<ul> <li>SandwichALPNError (error_codes.h)</li> <li>SandwichAPIError (error_codes.h)</li> <li>SandwichASN1Error (error_codes.h)</li> <li>SandwichCertificateError (error_codes.h)</li> <li>SandwichConfigurationError (error_codes.h)</li> <li>SandwichDataSourceError (error_codes.h)</li> <li>SandwichErrorKind (error_codes.h)</li> <li>SandwichHandshakeError (error_codes.h)</li> <li>SandwichKEMError (error_codes.h)</li> <li>SandwichPrivateKeyError (error_codes.h)</li> <li>SandwichProtobufError (error_codes.h)</li> <li>SandwichSocketError (error_codes.h)</li> <li>SandwichSystemError (error_codes.h)</li> <li>SandwichTLSConfigurationError (error_codes.h)</li> <li>SandwichTunnelError (error_codes.h)</li> <li>SandwichIOFlushFunctionPtr (io.h)</li> <li>SandwichIOReadFunction (io.h)</li> <li>SandwichIOReadFunctionPtr (io.h)</li> <li>SandwichIOWriteFunction (io.h)</li> <li>SandwichIOWriteFunctionPtr (io.h)</li> <li>SandwichOwnedIOFreeFunction (io.h)</li> <li>SandwichOwnedIOFreeFunctionPtr (io.h)</li> <li>SandwichIOError (ioerrors.h)</li> <li>SandwichTunnelConfigurationVerifierEmpty (tunnel.h)</li> <li>SandwichTunnelIOSetStateFunction (tunnel.h)</li> <li>SandwichTunnelIOSetStateFunctionPtr (tunnel.h)</li> <li>SandwichTunnelHandshakeState (tunnel_types.h)</li> <li>SandwichTunnelRecordError (tunnel_types.h)</li> <li>SandwichTunnelState (tunnel_types.h)</li> </ul>"},{"location":"cAPI/links.html","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}